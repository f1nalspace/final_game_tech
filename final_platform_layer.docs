// ****************************************************************************
//
// Documentation
//
// ****************************************************************************

/*!
	@mainpage
	@tableofcontents

	@section section_overview Overview

	Final Platform Layer is a Single-Header-File cross-platform C development library designed to abstract the underlying platform to a simple and easy to use api - providing low level access to (Window, Video, Audio, Input, File/Path IO, Threads, Memory, Hardware, etc.).<br>
	<br>
	The main focus is game/media/simulation development, so the default settings will create a window, setup a OpenGL rendering context and initialize audio playback on any platform.<br>
	<br>
	FPL supports the platforms <b>Windows</b>/<b>Linux</b>/<b>Unix</b> for the architectures <b>x86</b>/<b>x64</b>.<br>
	The only dependencies are built-in operating system libraries and a <b>C99</b> complaint compiler.<br>
	<br>
	It is released under the @subpage page_license "MIT License". This license allows you to use FPL freely in any software.<br>

	@section section_using_this_documentation How to use this documentation?
	Use the following links to learn more about FPL:
	- @subpage page_introduction
	- @subpage page_gettingstarted
	- @subpage page_categories
	- @subpage page_examples
	- @subpage page_faq
	- @subpage page_contribute
	- @subpage page_changelog
	- @subpage page_todo
	- @subpage page_knownissues
	- @subpage page_license

	I hope you find all the informations you need. If not please drop a issue on the github project page and it will be addressed as soon as possible!

	Thanks for using, have a great day!
*/

/*!
	@page page_introduction Introduction
	@tableofcontents

	@section section_intro Introduction to FPL

	@subsection subsection_intro_whatisfpl What is FPL?

	Final Platform Layer is a Single-Header-File cross-platform C development library designed to abstract the underlying platform to a very simple and easy to use api - providing low level access to:<br>
	- Single Window creation and handling
	- Graphics Software or Hardware Rendering initialization.
	- Playback of raw Audio Samples
	- Accessing Input Devices (Keyboard, Mouse, Gamepad)
	- IO handling (Files, Directories, Paths)
	- Multithreading (Threads, Mutexes, Signals, Conditions)
	- String conversions UTF8 <-> WideString
	- Allocating Memory
	- Retrieve Hardware & OS Informations
	
	The main focus is game/media/simulation development, so the default settings will create a window, setup a OpenGL rendering context and initialize audio playback on any platform.<br>
	<br>
	Final Platform Layer is released under the @subpage page_license "MIT License". This license allows you to use FPL freely in any software.<br>

	@subsection subsection_intro_whatissingleheaderfilelibrary What is a single-header-file Library and why is FPL based on that?
	A single header file library (as the name implies) is a development library designed to be one file only.<br>
	Such a file contains the header (API) and the body (Implementation) in one file but separated and controlled by compiler conditions.<br>
	Due to the nature of a single-header-file library all the source's comes with it - so it is most likely licensed by a public domain license.<br>
	In addition, such libraries mostly do not require any dependencies at all, to making it more friendly to the user.<br>
	This makes it easy to use the library however you want (with source, Static-linked, As a DLL, Private use only).<br>
	<br>
	So, why then is FPL based on that?<br>
	<br>
	Because normal libraries typically have a lot of disadvantages:
	- Force you to link to it dynamically or statically
	- Force you to use build-systems just to compile it
	- Requires specific CRT versions which make linking a madness
	- Require or come with a ton of dependencies
	- Are closed source or use an incompatible license
	- Takes ages to compile because of its hundreds of translation units

	@subsection subsection_intro_supported_platforms Which platforms are supported by FPL?
	Right now FPL supports just a couple of x86/x64 platforms, but some are already in progress and more are planned:

	- Windows (x86/x64)
	- Linux (x86/x64)
	- Unix (x86/x64, Partially)

	For more details see the page: @subpage page_platform_status
	
	@subsection subsection_intro_supported_compilers Which compilers are supported by FPL?
	FPL should compile on any C99 complaint compiler, such as MSVC 2015+, GCC, Clang, etc.

	@subsection section_intro_features What can FPL do?
	Read below a detailed feature overview of FPL:

	- Core
		- Compiler detection
		- Architecture detection
		- OS detection
	- Window
		- Create and handle a Single Window
		- Fullscreen toggling
		- Event handling
		- Clipboard string reading and writing
	- Input (Event-based or by Polling)
		- Text input (Event-based only)
		- Keyboard
		- Mouse
		- Game Controllers
	- Video:
		- Graphics initialization
		- Backends:
			- OpenGL 1.x (Legacy)
			- OpenGL 3.x or higher (Modern)
			- Software Backbuffer
	- Audio
		- Raw audio asyncronous playback
		- Device iteration and selection
		- Backends:
			- DirectSound
			- ALSA
	- Memory
		- Allocation and Deallocation
		- Custom Alignment functions
		- Fast Clear/Set and Copy
	- Atomics
		- Support for 8,16,32,64 bit signed and unsigned integer types
		- Support for void pointer type
		- Support for size type
		- Compare and Exchange (CAS)
		- Add / Exchange
		- Load / Store
		- Memory Barriers
	- Shared library
		- Loading of Shared Libraries (DLL on Windows, .so on Linux)
		- Function Pointer Lookup
	- IO
		- Path functions
			- Query User Home Directory
			- Query Executable Path
			- Extract Filename, Extension and Path
			- Combine Paths
			- Change File Extension
		- Files/Directories
			- Reading and Writing of Binary Files (32-bit and 64-bit)
			- Iterate over Files/Directories
			- Rename/Copy/Delete/Move operations
	- Hardware info retrievement
		- Query Processor Infos (Core count, Name)
		- Query Current Memory State (Physical size, Virtual Size, Page Size, etc.)
		- Query System Architecture
	- OS info retrievement
		- Query logged in Username
		- Query OS infos (Name, Version)
	- Timings
		- Get number of seconds (Low and High precision) used for profiling and delta calculations
		- Get number of milliseconds (Low and High precision) user for simple measurement
	- String conversion functions
		- UTF-8 <-> Widestring
		- Copy
		- Comparing
		- Matching
		- Formatting
	- Locales
		- Get keyboard/user/system locale
	- Console
		- Standard/Error out
		- Formatted out
		- Char input
	- Debug
		- DebugBreak for most compilers/platforms
		- DebugOut for limited compilers/platforms
	- Threading
		- Threads
		- Mutexes
		- Signals
		- Condition-Variables
		- Semaphores

	@subsection section_intro_getstarted How do i get started with FPL?
	- You download the latest <a href="https://github.com/f1nalspace/final_game_tech/blob/master/final_platform_layer.h">"final_platform_layer.h"</a> file.
	- Drop it into your C/C++ project and use it in any place you want.
	- Define **FPL_IMPLEMENTATION** in at least one translation unit before including this header file!
	- Ready to go.

	For more details see the pages: @subpage page_gettingstarted / @subpage page_categories / @subpage page_examples.
*/

/*!
	@page page_gettingstarted Getting started
	@tableofcontents

	@section section_usage_setup Download & Setup

	@subsection subsection_usage_setup_download Download

	- You download the latest <a href="https://github.com/f1nalspace/final_game_tech/blob/master/final_platform_layer.h">"final_platform_layer.h"</a> file.
	- Drop it into your C/C++ project and use it in any place you want.

	@subsection subsection_usage_setup_setup Setup?
	- No setup required

	@section section_usage_requirements Requirements

	FPL uses built-in operating system libraries and requires a C99 complaint compiler.<br>
	Depending on the compiler and platform - linking to one system library may be needed:

	@subsection usage_requirements_win32 Win32
	- Link against "kernel32.lib"

	@subsection usage_requirements_unix Unix/Linux
	- Link against "libld.so"

	@subsection usage_requirements_crt C-Runtime
	By default FPL uses the C-Run-Time library for functions such as vsnprintf(), but its usage is optional.<br>
	For more details see the page @subpage page_nocrt

	@section section_usage_howtouse How to use FPL?
	In one of your C/C++ translation units include this:

	@code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"
	@endcode

	You can then include this file in any other C/C++ source or header file as you would with any other header file.

	Provide the typical main entry point with at least the initialization and release of the platform:

	@code{.c}
	int main(int argc, char **argv) {
		// Initialize the platform
		if (fplPlatformInit(fplInitFlags_All, fpl_null)) {

			// your code goes here

			// Release the platform
			fplPlatformRelease();
			return 0;
		} else {
			return -1;
		}
	}
	@endcode

	@section section_usage_multiple_translation_units How to use FPL in multiple translation units?

	To use FPL in multiple translation units, it is recommended creating a separated "final_platform_layer.c" in the same directory FPL is located and define the implementation there only:<br>

	<b>final_platform_layer.c</b>:
	@code{.c}
	#define FPL_IMPLEMENTATION
	#define FPL_NO_ENTRYPOINT // Disable the entry point inclusion
	#include "final_platform_layer.h"
	@endcode

	This way FPL implementation is compiled once and can be used everywhere.<br>
	<br>
	In your main translation unit you just include the entry point only using the preprocessor define **FPL_ENTRYPOINT**.

	<b>main_translation_unit.c</b>:
	@code{.c}
	#define FPL_ENTRYPOINT // Integrate entrypoint only
	#include "final_platform_layer.h"
	@endcode

	@section section_usage_static_library How to use FPL in a static library?

	To use FPL as a/in static library you do the same steps required for using FPL in multiple translation units.
	See @ref section_usage_multiple_translation_units for more details.

	@section section_usage_codecomments How do i get the code-documentation to show up in the IDE?

	When FPL is compiled directly in your main translation unit, some IDE's read the comments from the implementation bodies instead from the header definitions.<br>
	This is obviously wrong, but we can't help it. Those editors just are not designed for single-header-file libraries :-(

	But do not fear, you can get the comments to show up in your IDE properly, just compile the implementation into a separated translation unit only.<br>
	This way the IDE will parse the comments from the api declaration only. See @ref section_usage_multiple_translation_units for more details.

	@section section_usage_options Options
	See @subpage page_compiler_options for all compile time options.
*/

/*!
	@page page_categories Categories
	@tableofcontents

	@section section_category_general General
	@subpage page_category_initialization <br>
	@subpage page_category_errorhandling <br>
	@subpage page_category_logging <br>

	@section section_category_window Window
	@subpage page_category_window_basics <br>
	@subpage page_category_window_events <br>
	@subpage page_category_window_style <br>

	@section section_category_input Input
	@subpage page_category_input_events <br>
	@subpage page_category_input_polling <br>
	@subpage page_category_input_config <br>

	@section section_category_memory Memory
	@subpage page_category_memory_handling <br>

	@section section_category_hardware Hardware
	@subpage page_category_hardware <br>

	@section section_category_software OS/Session
	@subpage page_category_ossession <br>

	@section section_category_dll Dynamic Library Loading
	@subpage page_category_dll <br>

	@section section_category_io File IO
	@subpage page_category_io_binaryfiles <br>
	@subpage page_category_io_paths <br>

	@section section_category_threading Multithreading
	@subpage page_category_threading_threads <br>
	@subpage page_category_threading_mutexes <br>
	@subpage page_category_threading_signals <br>
	@subpage page_category_threading_conditions <br>
	@subpage page_category_threading_semaphores <br>
	@subpage page_category_threading_atomics <br>
	@subpage page_category_threading_sync <br>

	@section section_category_video Video
	@subpage page_category_video_general <br>
	@subpage page_category_video_legacy_opengl <br>
	@subpage page_category_video_modern_opengl <br>
	@subpage page_category_video_software <br>

	@section section_category_audio Audio
	@subpage page_category_audio_general <br>
	@subpage page_category_audio_writesamples <br>
*/

/*!
	@page page_category_initialization Initialization & Release
	@tableofcontents

	@section section_category_initialization_include Include the Library

	In one of your C/C++ translation units include this:

	@code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"
	@endcode

	You can then include this file in any other C/C++ source or header file as you would with any other header file.

	@section section_category_initialization_entrypoint Entry Point

	Simply provide the typical main entry point:<br>

	@code{.c}
	int main(int argc, char **argv) {
		// code goes here
	}
	@endcode

	@section section_category_initialization_simple Initialization with default settings

	Call @ref fplPlatformInit() (inside the main @ref section_category_initialization_entrypoint) and provide the desired @ref fplInitFlags and @ref fpl_null as argument, to initialize FPL with default settings.

	@code{.c}
	int main(int argc, char **argv) {
		// With defaults (Window, Video, Audio)
		fplPlatformInit(fplInitFlags_All, fpl_null);

		// Only audio
		fplPlatformInit(fplInitFlags_Audio, fpl_null);

		// Only window and audio
		fplPlatformInit(fplInitFlags_Window | fplInitFlags_Audio, fpl_null);

		return 0;
	}
	@endcode

	It is recommended to always pass pointer to a @ref fplSettings structure, but you can leave it as @ref fpl_null as well.<br>
	Call @ref fplSetDefaultSettings() with a pointer to your local settings container to initialize the settings container with default values.

	@section section_category_initialization_with_settings Initialization with custom settings

	Call @ref fplPlatformInit() (inside the main @ref section_category_initialization_entrypoint) and provide the desired @ref fplInitFlags and a pointer to @ref fplSettings argument to initialize FPL with custom settings.

	@code{.c}
	// Overwrite settings
	fplSettings settings;
	fplSetDefaultSettings(&settings);

	// or
	fplSettings settings = fplMakeDefaultSettings();

	// change the settings here

	fplPlatformInit(fplInitFlags_All, &settings);
	@endcode

	@section section_category_initialization_release Releasing the Platform

	Call @ref fplPlatformRelease() when you are done. This will release all internal resources.<br>
	
	@code{.c}
	fplPlatformRelease();
	@endcode

	@section section_category_initialization_result Result/Error checking

	There is no guarantee that @ref fplPlatformInit() will always work with the fplSettings you specified, maybe the audio device does not support a sample rate of 1337 Khz or your video card does not support OpenGL version 3.7 - who knows.<br>
	<br>
	Therefore, you should always check the result using @ref fplGetPlatformResult() !<br>
	This returns a @ref fplPlatformResultType enum which is @ref fplPlatformResultType_Success when initialization succeeded.<br>
	<br>
	Also, you should release the platform when the initialization was successful only!<br>
	If something goes wrong the remaining resources are already cleaned up by FPL automatically.<br>
	<br>
	In addition you should use @ref fplGetLastError() to print out the actual error when the initialization fails!<br>

	<b>Very bad:</b> (But will work)
	@code{.c}
	fplPlatformInit(fplInitFlags_All, fpl_null);

	// your code here

	fplPlatformRelease();
	@endcode

	<b>Bad:</b> (But will work)
	@code{.c}
	if (fplPlatformInit(fplInitFlags_All, fpl_null)) {
		// your code here
	}
	fplPlatformRelease();
	@endcode

	<b>Good:</b>
	@code{.c}
	if (fplPlatformInit(fplInitFlags_All, fpl_null)) {
		// your code here
		fplPlatformRelease();
	}
	@endcode

	<b>Better:</b>
	@code{.c}
	if (fplPlatformInit(fplInitFlags_All, fpl_null)) {
		// your code here
		fplPlatformRelease();
	} else {
		const char *errStr = fplGetLastError();
		fplConsoleFormatError("FPL-ERROR: %s\n", errStr);
	}
	@endcode

	<b>Much better:</b>
	@code{.c}
	if (fplPlatformInit(fplInitFlags_All, fpl_null)) {
		// your code here
		fplPlatformRelease();
	} else {
		fplPlatformResultType initResult = fplGetPlatformResult();
		const char *initResultStr = fplGetPlatformResultTypeString(initResult);
		const char *errStr = fplGetLastError();
		fplConsoleFormatError("FPL-ERROR[%s]: %s\n", initResultStr, errStr);
	}
	@endcode

	See the @subpage page_category_errorhandling page for more details about error handling.
	
	@section section_category_initialization_tips Tips
	After releasing FPL you can call @ref fplPlatformInit() again if needed - for example: Finding the proper audio device, Testing for OpenGL compatibility, etc. may require you to call @ref fplPlatformInit() and @ref fplPlatformRelease() multiple times.<br>
	For more details see @ref page_gettingstarted<br>
	<br>
	Optionally you can use @ref fplMakeDefaultSettings to create a default filled @ref fplSettings structure, which can be directly used for @ref fplPlatformInit()<br>
	<br>
	If needed you can get the currently used @ref fplSettings configuration by calling @ref fplGetCurrentSettings()
*/

/*!
	@page page_category_errorhandling Error handling
	@tableofcontents

	@section section_category_errorhandling_getplatformresult Check platform result

	Use @ref fplGetPlatformResult() to query the current platform result.<br>
	This is useful to check if @ref fplPlatformInit() was already called or not.
	Also, this is useful to see which system failed in @ref fplPlatformInit() .

	Example:
	@code{.c}
	fplPlatformResultType resultType = fplGetPlatformResult();
	switch (resultType) {
		case fplPlatformResultType_NotInitialized:
			printf("Platform is not initialized yet!");
			break;
		case fplPlatformResultType_FailedAudio:
			printf("The audio system failed to initialize: %s", fplGetLastError());
			break;
	}
	@endcode

	@note You may combine @ref fplGetPlatformResult() with @ref fplGetLastError, to get a more understanding what exactly went wrong.

	@section section_category_errorhandling_getlatest Get latest error

	In case something goes wrong you can always call @ref fplGetLastError() - at any time, regardless if it is initialized or not.<br>
	This either returns an empty string indicating everything is fine or a formated string with a valid error message.<br>

	Example:
	@code{.c}
	const char *errStr = fplGetLastError();
	// Do something with the error string
	@endcode

	@section section_category_errorhandling_count Was there a error?

	If you just want to check if there was an error, you can call @ref fplGetErrorCount() to use the number of errors as a condition.<br>

	Example:
	@code{.c}
	if (fplGetErrorCount()) {
		// Print out the error message
	}
	@endcode

	@section section_category_errorhandling_getbyindex Get error by index

	Use @ref fplGetErrorByIndex() to get a error string for the given index in range @ref fplGetErrorCount() .

	Example:
	@code{.c}
	size_t errorCount = fplGetErrorCount();
	if (errorCount > 0) {
		const char *lastError = fplGetErrorByIndex(errorCount - 1);
		// Do something with the last error
	}
	@endcode
	
	@section section_category_errorhandling_clear Clearing the errors

	Errors will never be cleared by FPL! You have to do this yourself using @ref fplClearErrors() .<br>

	Example:
	@code{.c}
	fplClearErrors();
	@endcode
*/

/*!
	@page page_category_logging Debug & Logging
	@tableofcontents

	@section section_category_logging_logging Logging

	FPL has a internal logging system built-in.<br>
	By default this logging system is disabled, but you can enable it you by defining the preprocessor definition **FPL_LOGGING** before including the FPL header file.<br>
	<br>
	You can change the maximum log-level using @ref fplSetMaxLogLevel() . By default this is set to @ref fplLogLevel_Critical which means that only system-wide critical errors will be reported.<br>
	When the logging system is enabled, you can get or change the configuration using @ref fplGetLogSettings() / @ref fplSetLogSettings() respectively.<br>

	This configuration has two modes, a mode which you can define one writer for every log level and one mode which you have a writer for each log-level separately. By default it uses the first mode, which is one writer for all log-levels.<br>
	To change this behavior, you can set the preprocessor definition **FPL_LOG_MULTIPLE_WRITERS**. With this you can change the logging in very detail.<br>

	A log writer can be configured to log to multiple logging-targets.<br>
	<br>
	FPL supports up-to 4 log-targets:
	- Console standard output
	- Console error output
	- Debug console output
	- Custom callback

	See @ref fplLogWriterFlags and @ref fplLogSettings for more details.

	@subsection subsection_category_logging_logging_example_console_only Example: Log everything to the standard console only

	@code{.c}
	fplLogSettings logSettings = fplZeroInit;
	logSettings.maxLevel = fplLogLevel_All;
	logSettings.writers[0].flags = fplLogWriterFlags_StandardConsole;
	fplSetLogSettings(&logSettings);
	@endcode

	@subsection subsection_category_logging_logging_example_errors_only Example: Log all errors to the error console only

	Log all errors, warnings and criticals to the default error console.
	
	@code{.c}
	fplLogSettings logSettings = fplZeroInit;
	logSettings.maxLevel = fplLogLevel_Error;
	logSettings.writers[0].flags = fplLogWriterFlags_ErrorConsole;
	fplSetLogSettings(&logSettings);
	@endcode

	@subsection subsection_category_logging_logging_example_custom Example: Log all errors to a custom logging function
	
	Log all errors, warnings and criticals to a custom callback defined as @ref fpl_log_func_callback .

	@code{.c}
	static void MyLogFunction(const fplLogLevel level, const char *message) {
		// ...
	}

	fplLogSettings logSettings = fplZeroInit;
	logSettings.maxLevel = fplLogLevel_Error;
	logSettings.writers[0].flags = fplLogWriterFlags_Custom;
	logSettings.writers[0].custom.callback = MyLogFunction;
	fplSetLogSettings(&logSettings);
	@endcode

	@section section_category_logging_debug Debug

	@subsection subsection_category_logging_debug_break Forced Breakpoint

	You can force to stop on a specific line of code always by calling the function @ref fplDebugBreak() .<br>
	It works exactly like a breakpoint, but it will always break until you remove the call to it.

	Example:
	@code{.c}
	// ... code
	fplDebugBreak(); // Debugger will always stop here
	// ... code
	@endcode

	@subsection subsection_category_logging_debug_out Output to the Debug-Console

	On IDE's such as visual studio you can use @ref fplDebugOut() or @ref fplDebugFormatOut() to print out stuff in the console directly in your IDE.<br>

	Example:
	@code{.c}
	// Basic output
	fplDebugOut("Debug-Values:\n");

	// or

	// Formatted output
	fplDebugFormatOut("Value of X: %f\n", xValue);
	@endcode

	@section section_category_assertions Assertions

	FPL contains a runtime and a compile time assertion macro, which you can use to ensure application state consistency.
	
	@subsection subsection_category_assertions_runtime Runtime assertion

	You can use the macro function @ref fplAssert() to trigger a runtime assertion in a debug-build.<br>
	When the condition in your assertion is false, your application will crash immediately.

	Example:
	@code{.c}
	// When i is less than 5 this code will trigger a assertion which will crash your application immediatly.
	fplAssert(i >= 5);

	// Will trigger a assertion when the "str" pointer is null.
	fplAssert(str != fpl_null);
	@endcode

	@warning When you are building in release-mode runtime-time assertions are compiled out entirely - unless you have specific **FPL_FORCE_ASSERTIONS**!
	@warning Do not call any important functions inside an assertion statement, because it will get compiled out eventually.

	@subsection subsection_category_assertions_static Compile time / static assertion

	You can use the macro function @ref fplStaticAssert() to trigger a compile-time assertion in a debug-build.<br>

	Example:
	@code{.c}
	typedef struct myStruct {
	  int a;
	  float b;
	} myStruct;

	// Will throw a compile error when "myStruct" is not of total size of 8-bytes
	fplStaticAssert(sizeof(myStruct) == 8);
	@endcode

	@warning When you are building in release-mode compile-time assertions are compiled out entirely - unless you have specific **FPL_FORCE_ASSERTIONS**!
	@warning Do not call any important functions inside an assertion statement, because it will get compiled out eventually.

	@subsection subsection_category_assertions_enabledisable Enable/Disable assertions

	In Debug-Mode assertions are enabled, unless you have specified **FPL_NO_ASSERTIONS**.<br>
	In Release-Mode assertions are disabled, unless you have specified **FPL_FORCE_ASSERTIONS**.<br>
	<br>
	You can use **FPL_DEBUG** or **FPL_RELEASE** to force either a "Release" or "Debug" mode.<br>
	See @subpage page_compiler_options for more details.<br>
	@note I highly recommend to never define this in your code, but rather outside in your build-configuration.


*/

/*!
	@page page_category_window_basics Window basics
	@tableofcontents

	@section section_window_basics_init Initialization

	To create a window, you add the @ref fplInitFlags_Window flag to the @ref fplInitFlags argument in the @ref fplPlatformInit() call.<br>
	It makes no sense to create a window alone, so we combine it at least with something else, like for example: a video context or audio playback.<br>

	@code{.c}
	fplPlatformInit(fplInitFlags_Window | fplInitFlags_Video, fpl_null);
	@endcode

	@section section_window_basics_mainloop Main loop

	After you initialize FPL with a window, you have to create some sort of a loop to keep the window open until you close them.<br>
	This is required due to the fact that the operating systems use a event-based system to communicate with the window and your application.<br>
	If no communication happens with your window and your app, the window will no longer be responsive - so make sure to communicate properly.<br>
	<br>
	To solve this, you have to use @ref fplWindowUpdate() and @ref fplPollEvent() respectively.
	<br>
	First you need to call @ref fplWindowUpdate() for every 'tick' for your application. This will clear the internal event queue and update input devices properly.<br>
	After that you have to poll all events from the operating systems event queue using @ref fplPollEvent() .<br>

	@code{.c}
	while (fplWindowUpdate()) {
		fplEvent ev;
		while (fplPollEvent(&ev)) {
			// ... Handle event here
		}
	}
	@endcode

	See @subpage page_category_window_events for more details.<br>

	@attention All window based calls are required to be executed from the main-thread only!

	@section section_window_basics_shutdown Shutdown the window

	Simply call @ref fplWindowShutdown to shutdown the window, while it is still running.<br>
	<br>
	You can also query the running state of the window by calling @ref fplIsWindowRunning() .<br>

	@note The window is not immediately shut-down, one tick of window/input events may still be executed after that.<br>To forcefully terminate the window, use @ref fplPlatformRelease() instead.

*/

/*!
	@page page_category_window_events Window events
	@tableofcontents

	@section section_category_window_events_polling Polling the window events

	Call @ref fplPollEvent() in a while-loop inside your actual main-loop with a pointer to a @ref fplEvent argument to poll the next event from the OS event queue.<br>
	Each event is translated into the @ref fplEvent argument which you can handle or not. If there are no events left, the function returns false.

	@code{.c}
	fplEvent currentEvent;
	while (fplPollEvent(&currentEvent)) {
		// ... Handling the event
	}
	@endcode

	@section section_category_window_events_handling Handling the Events

	Each event has a @ref fplEvent.type field which you can check on to read the actual data (Keyboard, Mouse, Window, etc.).

	@code{.c}
	fplEvent currentEvent;
	while (fplPollEvent(&currentEvent)) {
		switch (currentEvent.type) {
			case fplEventType_Window:
			{
				// A window event, like resize, lost/got focus, etc.
				switch (currentEvent.window.type) {
					// ...
				}
			} break;
			case fplEventType_Keyboard:
			{
				// A keyboard event, like key down/up, pressed, etc.
				switch (currentEvent.keyboard.type) {
					// ...
				}
			} break;
			case fplEventType_Mouse:
			{
				// A mouse event, like mouse button down/up, mouse move, etc.
				switch (currentEvent.mouse.type) {
					// ...
				}
			} break;
			case fplEventType_Gamepad:
			{
				// A gamepad event, like connected/disconnected, state-updated etc.
				switch (currentEvent.gamepad.type) {
					// ...
				}
			} break;
		}
	}
	@endcode

	All available event types are stored in the @ref fplEventType enumeration.

	@section section_category_window_events_handle_event_type Handle the event data

	All relevant event data are stored in fields which match the lowercase @ref fplEventType name.<br>
	Each event structure has another type field to check for the actual type (Key-Down, Mouse-Move, Window-Resize etc.).<br>

	@subsection subsection_category_window_events_handle_event_buttonstate Button states

	All mouse/keyboard or gamepad button states are descriped as a @ref fplButtonState.<br>
	<br>
	To detect a non-repeatable button press, you simply compare against @ref fplButtonState_Press.<br>
	To detect a repeatable button press, you simply compare against @ref fplButtonState_Repeat.<br>
	To detect a non button press, you simply compare against @ref fplButtonState_Release.<br>
	<br>
	If you just want to know if a key is pressed or hold-down, just do a greater equals comparisons of @ref fplButtonState_Press and you are golden.

	@subsection subsection_category_window_events_handle_event_type_mouse Mouse events

	Mouse event data are stored in the @ref fplMouseEvent structure.<br>
	A mouse event contains either a single button click/release, or a mouse wheel change or a position change.<br>

	@code{.c}
	switch (currentEvent.mouse.type) {
		case fplMouseEventType_Button:
		{
			fplMouseButtonType button = currentEvent.mouse.button;
			fplButtonState state = currentEvent.mouse.buttonState;
			bool buttonDown = state >= fplButtonState_Press;
			switch (button) {
				case fplMouseButtonType_Left:
				{
					// Left mouse button down/released
				} break;
				case fplMouseButtonType_Middle:
				{
					// Middle mouse button down/released
				} break;
				case fplMouseButtonType_Right:
				{
					// Right mouse button down/released
				} break;
			}
		} break;

		case fplMouseEventType_Wheel:
		{
			float wheelDelta = currentEvent.mouse.wheelDelta;
			if (wheelDelta < 0.0f) {
				// Mouse-wheel down
			} else if (wheelDelta > 0.0f) {
				// Mouse-wheel up
			}
		} break;

		case fplMouseEventType_Move:
		{
			int mouseX = currentEvent.mouse.mouseX;
			int mouseY = currentEvent.mouse.mouseY;
			// ... do something with the mouse position
		} break;
	}
	@endcode

	@note Any mouse button event contains the position of the click as well.

	@subsection subsection_category_window_events_handle_event_type_keyboard Keyboard events

	Keyboard event data are stored in the @ref fplKeyboardEvent structure.<br>
	<br>
	You can either check for the original @ref fplKeyboardEvent.keyCode or use the fplKeyboardEvent.mappedKey field - which is much easier and less error prone.<br>

	@code{.c}
	switch (currentEvent.keyboard.type) {
		case fplKeyboardEventType_KeyButton:
		{
			fplButtonState state = currentEvent.keyboard.buttonState;

			// ... Handle the key code
			uint64_t keyCode = currentEvent.keyboard.keyCode;
			if (state >= fplButtonState_Pressed) {
				if (keyCode == 65 || keyCode == 97) {
					// Letter A is held down
				}
			}

			// or

			// ... handle the mapped key
			fplKey mappedKey = currentEvent.keyboard.mappedKey;
			if (state == fplButtonState_Released) {
				if (mappedKey == fplKey_F1) {
					// F1 key pressed
				}
			}
		} break;

		case fplKeyboardEventType_CharInput:
		{
			if(currentEvent.keyboard.keyCode > 0 && event.keyboard.keyCode < 0x10000) {
				// Handle character input
			}
		} break;
	}
	@endcode

	@subsection subsection_category_window_events_handle_event_type_gamepad Gamepad events

	Gamepad event data are stored in the @ref fplGamepadEvent structure.<br>

	@code{.c}
	switch (currentEvent.gamepad.type) {
		case fplGamepadEventType_Connected:
		{
			// New gamepad device connected
		} break;

		case fplGamepadEventType_Disconnected:
		{
			// Lost connection to a gamepad device
		} break;

		case fplGamepadEventType_StateChanged:
		{
			// State of one controller updated (Buttons, Movement, etc.)
			if (absf(currentEvent.gamepad.leftStickX) > 0) {
				// ... Handle horizontal movement on left stick
			}
			if (currentEvent.gamepad.actionX.isDown) {
				// ... X-Button is held down
			}
		} break;
	}
	@endcode

	@subsection subsection_category_window_events_handle_event_type_window Window events

	Window event data are stored in the @ref fplWindowEvent structure.<br>

	@code{.c}
	switch (currentEvent.window.type) {
		case fplWindowEventType_Resized:
		{
			uint32_t newWidth = currentEvent.window.width;
			uint32_t newHeight = currentEvent.window.height;
			// ... Window was resized, handle it properly
		} break;

		case fplWindowEventType_GetFocus:
		case fplWindowEventType_LostFocus:
		{
			// ... Do something when window lost/got focus
		} break;

		case fplWindowEventType_Exposed:
		{
			// ... Do something when window was exposed
		} break;

		case fplWindowEventType_DropSingleFile:
		{
			const char *filePath = ev.window.dropFiles.single.filePath;
			// ... Do something when window got a single file dropped into it
		} break;

		case fplWindowEventType_Minimized:
		case fplWindowEventType_Maximized:
		case fplWindowEventType_Restored:
		{
			// ... Do something when window state was changed
		} break;
	}
	@endcode

	@section section_category_window_events_process Ignoring the events

	When you don't care about any events you can simply call @ref fplPollEvents() to process the events and be done with it.<br>

	@code{.c}
	while (fplWindowUpdate()) {
		fplPollEvents();

		// ... Your code
	}
	@endcode

	@section section_category_window_events_inotes Important Notes

	@note FPL does not cache the events from the previous update. If you don't handle or cache the event - the data is lost!
*/

/*!
	@page page_category_window_style Window style & layout
	@tableofcontents

	@section section_category_window_style_style Reading/Setting the style

	@subsection subsection_category_window_style_style_decorated Decoration (Border, Titlebar)

	By default a window is decorated, meaning that it has a border, a titlebar and can be moved by the user.<br>
	If you enable window decorations, your window will have a border and a titlebar always.<br>
	<br>
	Use @ref fplIsWindowDecorated() to determine if the window has decoration enabled or not.<br>
	Use @ref fplSetWindowDecorated() to enable/disable the window decoration.<br>

	<b>Example:</b>
	@code{.c}
	// Enable window decoration
	fplSetWindowDecorated(true);

	// Disable window decoration
	fplSetWindowDecorated(false);

	// Toggle window decoration
	fplSetWindowDecorated(!fplIsWindowDecorated());
	@endcode

	@note You can overwrite the default decoration behavior by changing value in @ref fplWindowSettings.isDecorated from the @ref fplSettings.window field at startup.

	@subsection subsection_category_window_style_floating Floating (Always on top)

	By default a window is not in floating mode. This means when another window gets focus, your window loses its focus.<br>
	If you set your window to floating instead, your window will always be on top over others.<br>
	<br>
	Use @ref fplIsWindowFloating() to determine if the window is floating or not.<br>
	Use @ref fplSetWindowFloating() to enable/disable the window floating.<br>

	<b>Example:</b>
	@code{.c}
	// Enable window floating
	fplSetWindowFloating(true);

	// Disable window floating
	fplSetWindowFloating(false);

	// Toggle window floating
	fplSetWindowFloating(!fplIsWindowFloating());
	@endcode

	@note You can overwrite the default floating behavior by changing value in @ref fplWindowSettings.isFloating from the @ref fplSettings.window field at startup.

	@subsection subsection_category_window_style_resizable Resizeable

	By default a window is resizeable. This means you can resize your window however you like.<br>
	<br>
	Use @ref fplIsWindowResizable() to determine if the window is resizable or not.<br>
	Use @ref fplSetWindowResizeable() to enable/disable the window resizing.<br>

	<b>Example:</b>
	@code{.c}
	// Enable resizing of the window
	fplSetWindowResizeable(true);

	// Disable resizing of the window
	fplSetWindowResizeable(false);

	// Toggle window resizing mode
	fplSetWindowResizeable(!fplIsWindowResizable());
	@endcode

	@note You can overwrite the default resizable behavior by changing value in @ref fplWindowSettings.isResizable from the @ref fplSettings.window field at startup.

	@section section_category_window_style_size Getting/Changing the size/position

	@subsection subsection_category_window_style_size_pos Window position

	By default a window uses either the default position from the platform or a fixed location of 0x0 screen units.<br>
	<br>
	Use @ref fplSetWindowPosition() to change the position of the window
	Use @ref fplGetWindowPosition() to retrieve the current absolute window position from the top-left corner

	<b>Example:</b>
	@code{.c}
	// Retrieve absolute window position
	fplWindowPosition curPos;
	if (fplGetWindowPosition(&curPos)) {
		// Do something with the window position
	}

	// Change window absolute position to 0x0
	fplSetWindowPosition(0, 0);
	@endcode

	@subsection subsection_category_window_style_size_window Window size

	By default a window is created using either the default size of the platform or a fixed size of 400x400 screen units.<br>
	<br>
	Use @ref fplSetWindowSize() to change the size of the area of the window.<br>
	Use @ref fplGetWindowSize() to get the size of the area of the window.<br>

	<b>Example:</b>
	@code{.c}
	// Retrieve window inner/client size
	fplWindowSize curSize;
	if (fplGetWindowSize(&curSize)) {
		// Do something with the client size
	}

	// Change window size to fit 800x600 screen units inside the client area
	fplSetWindowSize(800, 600);
	@endcode

	@note You can overwrite the default window size by changing value in @ref fplWindowSettings.windowSize from the @ref fplSettings.window field at startup.
	@note Changing the window size, changes the total size of the window - when decorations are enabled.

	@subsection subsection_category_window_style_size_fullscreen Fullscreen size

	By default the window is created in non-fullscreen mode, using @ref fplWindowSettings.windowSize from the @ref fplSettings.window or
	the default window size. See @ref subsection_category_window_style_size_window for more details.<br>
	<br>
	Use @ref fplSetWindowFullscreenSize() to enable/disable fullscreen for the window with a given **size** and a **color depth** with support of switching the screen-resolution if needed.<br>
	Use @ref fplSetWindowFullscreenRect() to enable/disable fullscreen for the window with a given **size** and a **position** without changing the screen-resolution.<br>
	Use @ref fplIsWindowFullscreen() to determine if the window is in fullscreen mode or not.<br>

	<b>Enable fullscreen example:</b>
	@code{.c}
	// Enable fullscreen on the nearest desktop
	fplEnableWindowFullscreen();

	// or

	// Enable fullscreen on the nearest desktop
	fplSetWindowFullscreenSize(true, 0, 0, 0);

	// Enable 1080p fullscreen on the nearest desktop
	fplSetWindowFullscreenSize(true, 1920, 1080, 0);

	// Switch to 1080p screen resolution with a refresh rate of 60 Hz on the nearest desktop
	fplSetWindowFullscreenSize(true, 1920, 1080, 60);

	// Enable a 4k stretched resolution on two 1080p monitor left-right configuration
	fplSetWindowFullscreenRect(true, 0, 0, 3840, 1080);
	@endcode

	<b>Disable fullscreen example:</b>
	@code{.c}
	// Disable fullscreen size
	fplSetWindowFullscreenSize(false, 0, 0, 0);

	// or

	// Disable fullscreen rect
	fplSetWindowFullscreenRect(false, 0, 0, 0, 0);

	// or

	// Disable fullscreen
	fplDisableWindowFullscreen();
	@endcode

	<b>Query fullscreen state:</b>
	@code{.c}
	if (fplIsWindowFullscreen()) {
		// Do something on fullscreen mode
	}

	// Toggle fullscreen
	fplSetWindowFullscreenSize(!fplIsWindowFullScreen(), 0, 0, 0);
	@endcode

	@note Set @ref fplWindowSettings.isFullscreen to true to enable fullscreen at startup.
	@note You can overwrite the fullscreen window size by changing value in @ref fplWindowSettings.fullscreenSize from the @ref fplSettings.window field at startup.
	@note You can overwrite the fullscreen refresh rate by changing value in @ref fplWindowSettings.fullscreenRefreshRate from the @ref fplSettings.window field at startup.
	@note If width or height in the fplWindowSettings.fullscreenSize field is zero, the current desktop rectangle is used from the nearest display.

	@section section_category_window_style_cursor Changing the window cursor

	By default the window has cursor enabled. Use @ref fplSetWindowCursorEnabled to show/hide the cursor.<br>

	<b>Example:</b>
	@code{.c}
	// Enable the cursor
	fplSetWindowCursorEnabled(true);

	// Disable the cursor
	fplSetWindowCursorEnabled(false);
	@endcode

	@section section_category_window_style_title Get/Set the window title

	By default the window has a unnamed like title. Use @ref fplSetWindowTitle to set a window title on runtime.<br>

	<b>Example:</b>
	@code{.c}
	// Set window title
	fplSetWindowTitle("My awesome application");

	// Get the window title
	char titleBuffer[FPL_MAX_NAME_LENGTH];
	fplGetWindowTitle(titleBuffer, fplArrayCount(titleBuffer));
	@endcode
	
	@note You can overwrite the window title by changing value in @ref fplWindowSettings.title from the @ref fplSettings.window field at startup.

	@section section_category_window_style_state Get/Set the window state

	By default the window has a normal default state.

	- Use @ref fplSetWindowState to change to state the window state to a different one.
	- Use @ref fplGetWindowState to retrieve to current state of the window

	<b>Example:</b>
	@code{.c}
	// Iconify the window
	fplSetWindowState(fplWindowState_Iconify);

	// Maximize the window
	fplSetWindowState(fplWindowState_Maximize);

	// Reset to the normal when not normal
	fplWindowState curState = fplGetWindowState();
	if (curState != fplWindowState_Normal) {
		fplSetWindowState(fplWindowState_Normal);
	}
	@endcode

	@note When the window is in fullscreen mode, @ref fplWindowState_Fullscreen is returned from @ref fplGetWindowState() always.
	@warning The window state @ref fplWindowState_Fullscreen can never be set.

	@section section_category_window_style_notes Notes
	
	@note Use @ref fplSetDefaultWindowSettings() to initialize a @ref fplWindowSettings to a default state.<br>
*/

/*!
	@page page_category_input_config Input configuration
	@tableofcontents
	
	@section section_catecory_input_config_param_controllerdetectionfrequency Controller detection frequency

	Use @ref fplInputSettings.controllerDetectionFrequency to change the frequency (in milliseconds) for detecting new or removed game controllers.

	If this is set to zero, new or removed game controllers are detected for every frame - which is not recommend due to performance issues.

	@section section_catecory_input_config_param_disabledevents Disable controller handling as events

	Set @ref fplInputSettings.disabledEvents to '1' to disable all game controller events, if needed.
		
	@section section_category_input_config_default Initialize to default settings
	
	If needed you can use @ref fplSetDefaultInputSettings to reset the @ref fplInputSettings structure to a default state.<br>
	<br>
	You dont have to use this call, if you have already initialized the @ref fplSettings structure by @ref fplMakeDefaultSettings() or @ref fplSetDefaultSettings()
*/

/*!
	@page page_category_input_events Input events
	@tableofcontents

	@section section_page_category_input_events_overview Overview

	Input events are triggered by your window event loop. To detect any key/button presses you simply handle the specific event type in your event-loop.<br>
	See the @subpage page_category_window_events page for more details.<br>
	<br>
	If you don't want to handle input this way, you can use polling instead - see @subpage page_category_input_polling for more details.

*/

/*!
	@page page_category_input_polling Polling of input states
	@tableofcontents

	@section section_category_input_polling_overview Overview

	FPL supports manual polling of input states for Keyboard/Gamepad/Mouse as well.<br>

	@subsection subsection_category_input_polling_disableevents Disable Input-Events

	If you are only use polling to get your input states, you should disable the input-events entirely.<br>
	This is done by simply setting the @ref fplInputSettings.disabledEvents to "1" in your @ref fplSettings structure.

	@subsection subsection_category_input_polling_keyboard Keyboard

	Use @ref fplPollKeyboardState to poll the current keyboard state.<br>
	This state contains all the raw/mapped button states and the modifier states.<br>

	@code{.c}
	fplKeyboardState keyboardState;
	if (fplPollKeyboardState(&keyboardState)) {
		if (keyboardState.buttonStatesMapped[fplKey_Space] >= fplButtonState_Press) {
			// Spacebar pressed
		}
	}
	@endcode

	See @ref fplKeyboardState for more details.

	@subsection subsection_category_input_polling_gamepad Gamepad

	Use @ref fplPollGamepadStates to poll the current states for all conntected game controllers.<br>
	This state contains all the buttons, digital-pad, the left/right stick position + trigger, etc.<br>

	@code{.c}
	fplGamepadStates gamepadStates;
	if (fplPollGamepadStates(&gamepadStates)) {
		for (int index = 0; index < fplArrayCount(gamepadStates.deviceStates); ++index) {
			fplGamepadState *gamepadState = gamepadStates.deviceStates + index;
			// ... do something with the gamepad state
		}
	}
	@endcode

	See @ref fplGamepadStates for more details.

	@note use @ref fplGamepadState.isConnected to check if the gamepad is actually connected or not.

	@subsection subsection_category_input_polling_mouse Mouse

	Use @ref fplPollMouseState to poll the current mouse state.<br>
	This state contains the state of all the buttons (Left, Right, Middle) and the position in pixels coordinates.<br>

	@code{.c}
	fplMouseState mouseState;
	if (fplPollMouseState(&mouseState)) {
		int mousePosX = mouseState.x;
		int mousePosY = mouseState.y;
		if (mouseState.buttonStates[fplMouseButtonType_Left] >= fplButtonState_Pressed) {
			// Left mouse button down
		}
	}
	@endcode

	See @ref fplMouseState for more details.

	@subsection subsection_category_input_polling_tips Tips

	@note You can always use all those polling functions, regardless of the @ref fplInputSettings.disabledEvents field!
*/

/*!
	@page page_category_video_general Initialization & Overview
	@tableofcontents

	@section category_video_general_init Initialize a video context

	To initialize either software or hardware video output, you have to set the @ref fplInitFlags_Video flag in the @ref fplPlatformInit() call and ensure that video is not disabled by a preprocessor directive **FPL_NO_VIDEO**.<br>

	Also setting the @ref fplInitFlags_Video flag ensures that the @ref fplInitFlags_Window flag is appended automatically.<br>

	@subsection category_video_general_init_default Default video output

	If you don't specify any settings then the video driver is automatically detected, depending on your operating system and supported hardware and software.<br>
	By default this is most likely be legacy OpenGL - which is supported on almost every video card on any OS.<br>
	<br>
	But this is not the recommended way to initialize video output, due to the fact that you are responsible for handling any video output yourself.<br>

	@code{.c}
	if (fplPlatformInit(fplInitFlags_Video)) {
		// ... your code here
	}
	@endcode

	@subsection category_video_general_init_setting_driver Setting the video driver

	It recommended setting at least the video driver manually, to ensure that you get either initialized with that driver properly or an error when your configuration is not supported.<br>
	<br>
	You do that by simply setting the @ref fplVideoDriverType field in your @ref fplVideoSettings structure which is included in the @ref fplSettings structure to the @ref fplPlatformInit() call.
	
	@code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be OpenGL
	videoSettings.driver = fplVideoDriverType_OpenGL;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// ... your code here
	}
	@endcode
	
	@section category_video_general_vsync Enable/Disable Vertical Synchronisation

	If you want to enable/disable vertical synchronisation you simply set the fplVideoSettings.isVSync field respectively.
	<br>
	@note There is no guarantee that vertical synchronisation is supported by your video device or selected driver.
	@note Software video output does not support vertical synchronisation!

	@section category_video_general_disable Disable unneeded Video Drivers

	To compile out certain video drivers, you simply specify the **FPL_NO_VIDEO_[Name of the video driver]** preprocessor directive.<br>
	But the @ref fplVideoDriverType in question is never removed from the enumeration - keep that in mind!<br>

	Example (Disable OpenGL Video Driver):

	@code{.c}
	#define FPL_NO_VIDEO_OPENGL
	#define FPL_IMPLEMENTATION
	#include <final_platform_layer.h>
	@endcode

	@section category_video_general_disable_all Disable all Video Output

	To compile out all video output code you define the **FPL_NO_VIDEO** preprocessor directive.

	@code{.c}
	#define FPL_NO_VIDEO
	#define FPL_IMPLEMENTATION
	#include <final_platform_layer.h>
	@endcode

	@note Keep in mind that this is not useful for window based applications!
	@note If you writing a console application and don't want any video output whatsoever you set the **FPL_NO_WINDOW** which automatically disables any video devices as well.

	@section category_video_general_notes Notes

	Driver types stored in the @ref fplVideoDriverType enumeration are not filtered away, even when you disable it by a preprocessor directive!<br>
	Keep that in mind when you initialize the video device.<br>
	<br>
	If needed you can use @ref fplSetDefaultVideoSettings() to fill in just the default video settings inside the @ref fplVideoSettings structure.<br>
*/

/*!
	@page page_category_video_legacy_opengl Legacy OpenGL
	@tableofcontents

	@section section_category_video_legacy_opengl_init Initialize Legacy OpenGL

	To initialize a legacy OpenGL (up to GL version 2.1) rendering context you simply set the @ref fplInitFlags_Video flag in the @ref fplPlatformInit() call and change the video driver type to @ref fplVideoDriverType_OpenGL and set the @ref fplOpenGLVideoSettings.compabilityFlags to @ref fplOpenGLCompabilityFlags_Legacy .<br>
	<br>
	This will work in ~99% on all supported platforms - if not please post an issue for that platform/configuration/video-card ;-)

	@code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be legacy OpenGL
	videoSettings.driver = fplVideoDriverType_OpenGL;
	videoSettings.opengl.compabilityFlags = fplOpenGLCompabilityFlags_Legacy;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// ... your code here
	}
	@endcode

	@section section_category_video_legacy_opengl_usage Usage

	@subsection subsection_category_video_legacy_opengl_usage_extensions Extensions loader

	To use features of OpenGL 1.2 or later you need some sort of a opengl extension loader which gives you access to the constants and functions like glMultiTexCoord2f().<br>
	For more details please check the modern OpenGL @ref subsection_category_video_modern_opengl_usage_extensions section.

	@subsection subsection_category_video_legacy_opengl_usage_present Presenting your frame

	Call @ref fplVideoFlip() to present the frame to the screen.<br>
	Its recommend calling this after each draw call of your frame at the end of the main-loop.
*/

/*!
	@page page_category_video_modern_opengl Modern OpenGL
	@tableofcontents

	@section section_category_video_modern_opengl_init Initialize a modern OpenGL Rendering Context

	To initialize a modern OpenGL (3.0+) rendering context, you simply set the @ref fplInitFlags_Video flag in the @ref fplPlatformInit() call and change the video driver type to @ref fplVideoDriverType_OpenGL and setup the following parameters:<br>
	- Set the @ref fplOpenGLVideoSettings.majorVersion to 3 or higher
	- Set the @ref fplOpenGLVideoSettings.minorVersion to 0 or higher
	- Set the @ref fplOpenGLVideoSettings.compabilityFlags to either a @ref fplOpenGLCompabilityFlags_Core or @ref fplOpenGLCompabilityFlags_Compability
	- Optionally add the @ref fplOpenGLCompabilityFlags_Forward flag for removing obsolete functions

	@code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be modern OpenGL with Core profile and for GL version 3.3
	videoSettings.driver = fplVideoDriverType_OpenGL;
	videoSettings.opengl.compabilityFlags = fplOpenGLCompabilityFlags_Core;
	videoSettings.opengl.majorVersion = 3;
	videoSettings.opengl.minorVersion = 3;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// ... modern context is ready
	}
	@endcode

	@section section_category_video_modern_opengl_usage Usage

	@subsection subsection_category_video_modern_opengl_usage_extensions Extensions loader

	To use modern OpenGL, you need some sort of a opengl extension loader which gives you access to the constants and functions like glCreateProgram().<br>
	You can either use a third-party C/C++ Library for doing that for you or use/write your own OpenGL loader. FPL should work in both ways.<br>
	<br>
	List of tested OpenGL loaders:
	- <a href="https://github.com/f1nalspace/final_game_tech/blob/master/final_dynamic_opengl.h">Final Dynamic OpenGL</a>
	- Glew

	@subsection subsection_category_video_modern_opengl_present Presenting your frame

	Call @ref fplVideoFlip() to present the frame to the screen.<br>
	Its recommend calling this after each draw call of your frame at the end of the main-loop.

	@subsection subsection_category_video_modern_opengl_multisampling Multisample anti-aliasing (MSAA)

	In a modern OpenGL context, you can activate multi sampling antialiasing (MSAA) to get smooth edges with a bit of performance costs out-of-the-box.<br>
	By default multisampling is disabled. To enable it, you simply set your desired multi sampling count in @ref fplOpenGLVideoSettings.multiSamplingCount .<br>

	@code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be modern OpenGL with Core profile and for GL version 3.3
	videoSettings.driver = fplVideoDriverType_OpenGL;
	videoSettings.opengl.compabilityFlags = fplOpenGLCompabilityFlags_Core;
	videoSettings.opengl.majorVersion = 3;
	videoSettings.opengl.minorVersion = 3;

	// Use 4x MSAA
	videoSettings.opengl.multiSamplingCount = 4;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// ... modern context is ready
	}
	@endcode

	@section section_category_video_modern_opengl_notes Notes
	FPL does not provide any opengl types, prototypes or functions - its fully up to the caller how to handle this.
	<br>
	Keep in mind that FPL does not work with platform abstraction libraries like GLFW or GLUT, but GLEW for example will work just fine.
*/

/*!
	@page page_category_video_software Software Output
	@tableofcontents

	@section section_category_video_software_init Initialize a Software Backbuffer

	To initialize software rendering output, you simply set the @ref fplInitFlags_Video flag in the @ref fplPlatformInit() call and change the video driver type to @ref fplVideoDriverType_Software.<br>
	Call @ref fplGetVideoBackBuffer() to get access to the pixel data.

	@code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplVideoSettings &videoSettings = settings.video;

	// Forcing the video driver to be software
	videoSettings.driver = fplVideoDriverType_Software;

	if (fplPlatformInit(fplInitFlags_Video, &settings)) {
		// Video software back buffer is ready
		fplVideoBackBuffer *videoBackBuffer = fplGetVideoBackBuffer();
	}
	@endcode

	@section section_category_video_software_usage Usage

	To use the software backbuffer you simply access the @ref fplVideoBackBuffer from the @ref fplGetVideoBackBuffer() function and update the pixels as needed.

	@subsection subsection_category_video_software_present Presenting your frame

	Call @ref fplVideoFlip() to draw the pixels from the backbuffer to the window.<br>
	Its recommend calling this after each draw call of your frame at the end of the main-loop.

	@subsection subsection_category_video_software_drawing Drawing

	Drawing is done by manually changing the pixels in the @ref fplVideoBackBuffer.pixels field.<br>
	Each pixel is stored as 32-bit with 4 RGBA components in little-endian (AA BB GG RR).<br>
	Lines are stored in top-down order - meaning that position "0" in the @ref fplVideoBackBuffer.pixels field is always the top-left corner of the bitmap!<br>
	To calculate the actual position for the current line, you simply multiply your Y-Index with the @ref fplVideoBackBuffer.lineWidth field.

	<b>Example (Filling all pixels to purple):</b>

	@code{.c}
	fplVideoBackBuffer *backBuffer = fplGetVideoBackBuffer();
	for (uint32_t y = 0; y < backBuffer->height; ++y) {
		uint32_t *p = (uint32_t *)((uint8_t *)backBuffer->pixels + y * backBuffer->lineWidth);
		for (uint32_t x = 0; x < backBuffer->width; ++x) {
			uint32_t color = 0xFFFF00FF;
			*p++ = color;
		}
	}
	@endcode

	@subsection subsection_category_video_software_outrect Limiting the output rectangle (Stretching vs non-stretched)

	To force the pixels to be shown in a fixed rectangle you simply enable the @ref fplVideoBackBuffer.useOutputRect field and update the @ref fplVideoBackBuffer.outputRect as needed.<br>
	This mimics a "viewport" which is similar to OpenGLs glViewport().<br>
	<br>
	If you don't use this feature all pixels are fully stretched to the current window area always!

	@note This viewport should not be greater than the actual window area dimension!

	<b>Example (Resize window event):</b>
	@code{.c}
	static fplVideoRect ComputeLetterbox(int windowWidth, int windowHeight, int backWidth, int backHeight) {
		return {};
	}
	fplVideoBackBuffer *backBuffer = fplGetVideoBackBuffer();
	backBuffer->useOutputRect = true;
	while (fplWindowUpdate()) {
		fplEvent ev;
		while (fplPollEvent(&ev)) {
			if (ev.type == fplEventType_Window) {
				if (ev.window.type == fplWindowEventType_Resized) {
					fplVideoRect newRect = ComputeLetterbox(ev.window.width, ev.window.height, backBuffer->width, backBuffer->height); // ... Compute new rectangle here (Letterbox or something)
					backBuffer->outputRect = newRect;
				}
			}
		}

		// ... Modify the pixels here (Draw call)

		fplVideoFlip();
	}
	@endcode

	<b>Example (Always before the draw call):</b>
	@code{.c}
	fplVideoBackBuffer *backBuffer = fplGetVideoBackBuffer();
	backBuffer->useOutputRect = true;
	while (fplWindowUpdate()) {
		fplEvent ev;
		while (fplPollEvent(ev)) {}

		fplWindowSize windowArea = fplGetWindowSize();
		fplVideoRect newRect = ComputeLetterbox(windowArea, backBuffer->width, backBuffer->height); // ... Compute new rectangle here (Letterbox or something)
		backBuffer->outputRect = newRect;

		// ... Modify the pixels here (Draw call)

		fplVideoFlip();
	}
	@endcode

	@subsection subsection_category_video_software_resize Resizing the backbuffer

	By default the video backbuffer is automatically resized when the dimension of the window area changes.<br>
	If you want to manually do this, you disable this feature in the @ref fplVideoSettings.isAutoSize field - in the @ref fplSettings.video configuration section.<br>
	<br>
	Call @ref fplResizeVideoBackBuffer() with a new width and height as argument, to force the backbuffer to be resized to the new dimension.<br>

	@warning Do not call this method while you are modifying pixels!

	@section section_category_video_software_notes Notes

	- There are no software rendering functions built-in! If you want to draw for example a circle, you have to roll out your own drawCircle() function - which may uses Bresenham as its base or something.<br>
	- Vertical synchronisation is not supported for software video drivers!
*/

/*!
	@page page_category_audio_general Initialization & Usage
	@tableofcontents

	@section section_category_audio_general_default_init Default initialization

	To initialize audio playback with default settings (Interleaved, 48 KHz, 2 Channels, signed 16-bit integer format), you have to set the @ref fplInitFlags_Audio flag in the @ref fplPlatformInit() call and ensure that audio is not disabled by a preprocessor directive **FPL_NO_AUDIO**.<br>

	@code{.c}
	if (fplPlatformInit(fplInitFlags_Audio, fpl_null)) {
		// ... your code here
	}
	@endcode

	@subsection subsection_category_audio_general_default_init_clientcallback Setting the client callback

	Next is to specify the client user callback which gets invoked regularly when the audio device requires new samples to play.<br>
	This @ref fpl_audio_client_read_callback "client callback" can be set up in the @ref fplAudioSettings.clientReadCallback field from the @ref fplSettings.audio or changed by calling @ref fplSetAudioClientReadCallback() :<br>

	@code{.c}
	static uint32_t MyAudioPlaybackCallback(const fplAudioDeviceFormat *nativeFormat, const uint32_t frameCount, void *outputSamples, void *userData) {
		// ... Fill audio frames here
	}

	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplAudioSettings &audioSettings = settings->audio;
	audioSettings.clientReadCallback = MyAudioPlaybackCallback;
	audioSettings.userData = // ... pointer to some user data
	if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
		// ... your code here
	}
	@endcode

	@note This step must be done before you actually start playing the audio!
	@note You can specify a user data pointer which gets passed to the client callback as well.

	@section section_category_audio_general_custom_init Custom initialization

	You can change several audio settings (Sample rate, Number of Channels, Format, etc.) before initializing the audio playback like this:<br>

	@code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplAudioSettings &audioSettings = settings.audio;
	audioSettings.clientReadCallback = MyAudioPlaybackCallback;
	audioSettings.userData = // ... pointer to some user data
	fplAudioDeviceFormat &audioDeviceFormat = audioSettings.deviceFormat;
	audioDeviceFormat.sampleRate = 48000;
	audioDeviceFormat.channels = 2;
	audioDeviceFormat.type = fplAudioFormatType_F32;
	if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
		// ... your code here
	}
	@endcode

	@note Please see the @ref section_category_audio_general_notes for possible limitations!

	@section section_category_audio_general_choosing_driver Choosing the audio driver

	By default FPL uses the first available audio driver which is supported on your platform.<br>
	If you want to force FPL to use a certain audio driver, you can do this by changing the @ref fplAudioSettings.driver field in the @ref fplAudioSettings structure:<br>

	@code{.c}
	fplSettings settings;
	fplSetDefaultSettings(&settings);
	fplAudioSettings &audioSettings = settings.audio;

	// Forcing to use the DirectSound audio driver
	audioSettings.driver = fplAudioDriverType_DirectSound;

	if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
		// ... your code here
	}
	@endcode

	Its recommend using the default @ref fplAudioDriverType_Auto which uses the first supported audio driver.

	@warning If your platform/system does not support the desired driver the audio and platform initialization will fail!

	@section section_category_audio_general_autoplay Automatic play/stop of audio samples playback

	By default FPL starts the playback of audio samples automatically, but only when @ref fplAudioSettings.clientReadCallback was set!<br>
	Also audio playback will be stopped when @ref fplPlatformRelease() is called as well.<br>
	<br>
	You can disable this behavior by changing the fields @ref fplAudioSettings.startAuto and fplAudioSettings.stopAuto in the @ref fplAudioSettings configuration respectively.<br>

	@section section_category_audio_general_manualplay Manual play/stop of audio samples playback

	For manual control of start/stop playback of audio samples use the following functions:
	- @ref fplPlayAudio() to start requesting and play audio samples.
	- @ref fplStopAudio() to stop the audio playback.

	@warning Please ensure that @ref fplStopAudio() is called before @ref fplPlatformRelease() always!

	@section section_category_audio_general_notes Notes

	There is no guarantee that you get the desired audio format you specified back!<br>
	You should always check the @ref fplAudioDeviceFormat "nativeAudioFormat" in your client callback and convert/write the correct samples the audio device expects!<br>
	<br>
	For more details see the page: @subpage page_category_audio_writesamples<br>
	<br>
	If needed you can use @ref fplSetDefaultAudioSettings() to fill in just the default video settings inside the @ref fplAudioSettings structure.<br>
*/

/*!
	@page page_category_audio_writesamples Writing audio samples
	@tableofcontents

	@section section_category_audio_writesamples_overview Overview

	To write audio samples in the audio client callback, you have to know at least four things:
	- Target format (S16, S24, F32, etc.)
	- Target number of channels (1 = Mono, 2 = Stereo, etc.)
	- Target sample rate (44 KHz, 48 Khz, etc.)
	- Number of frames required

	All these informations are provided by the @ref fpl_audio_client_read_callback callback function.<br>
	<br>
	Call @ref fplGetAudioHardwareFormat(), to get this information before the audio playback is started.

	@section section_category_audio_writesamples_functions Useful functions

	To help with sample computation there are several functions available:

	- @ref fplGetAudioHardwareFormat()
	- @ref fplGetAudioBufferSizeInFrames()
	- @ref fplGetAudioDriverString()
	- @ref fplGetAudioFormatString()
	- @ref fplGetAudioSampleSizeInBytes()
	- @ref fplGetAudioFrameSizeInBytes()
	- @ref fplGetAudioBufferSizeInBytes()

	@section section_category_audio_writesamples_s16 Writing 16-bit signed integer samples

	@code{.c}
	static uint32_t MyAudioPlaybackCallback(const fplAudioDeviceFormat *nativeFormat, const uint32_t frameCount, void *outputSamples, void *userData) {
		uint32_t result = 0;
		if (nativeFormat->type == fplAudioFormatType_S16) {
			int16_t *outSamples = (int16_t *)outputSamples;
			for (uint32_t frameIndex = 0; frameIndex < frameCount; ++frameIndex) {
				for (uint32_t channelIndex = 0; channelIndex < nativeFormat->channels; ++channelIndex) {
					*outSamples++ = // ... Getting a sample for the current frame/channel
					++result;
				}
			}
		} else {
			// ... handle other formats here
		}
		return result;
	}
	@endcode

	@section section_category_audio_writesamples_notes Notes

	- FPL does not provide any functionality for doing any kind of DSP or format conversion!<br>
	- You are responsible for filling out the samples in the correct format your audio device expects!
*/

/*!
	@page page_category_memory_handling Memory handling
	@tableofcontents

	FPL provides a couple of functions to allocate/set/clear memory for you.<br>
	You are free to use it as you like, but you can use malloc(), free() as well if you want to.

	@section section_category_memory_handling_normal Default/Unaligned memory allocation

	@subsection subsection_category_memory_handling_normal_allocate Allocate (n)-bytes of memory

	To allocate a block of contiguous memory, you simply call @ref fplMemoryAllocate() with the number of bytes you want to allocate.<br>
	This will return a pointer you can start to write into.

	@code{.c}
	// Allocate 4MB of memory
	void *myMemory = fplMemoryAllocate(fplMegaBytes(4));
	// ...

	// or you can allocate the type directly

	// Allocate a bunch of int's
	int *intArray = (int *)fplMemoryAllocate(sizeof(int) * 100000);
	intArray[0] = 42;
	// ...
	@endcode

	@note This function does nothing more than calling the proper operating-system function such as **VirtualAlloc()** or **mmap()** .
	@attention The memory is not guaranteed to be aligned, but depending on the OS it may be aligned to something.
	@warning Do not write before this pointer, otherwise you may overwrite meta-informations required for releasing the memory later on.

	@subsection section_category_memory_normal_free Free memory

	To free memory, you simply call @ref fplMemoryFree() with the base pointer of your memory and thats it.

	@code{.c}
	// Free a memory block allocated by fplMemoryAllocate
	fplMemoryFree(myMemory);
	@endcode

	@warning Do not call this function with a pointer allocated from @ref fplMemoryAlignedAllocate() , otherwise you will corrupt memory!

	@subsection subsection_category_memory_handling_normal_datalayout Data layout of default/unaligned memory

	Here you can see the full data-layout for a default/unaligned memory block:
	
	| 0 or 4/8 bytes for x86/x64                   | 0 or 4/8 bytes for x86/x64     | n-bytes                 |
	|----------------------------------------------|--------------------------------|-------------------------|
	| **Optional size of the entire memory block** | **Optional padding**           | **Memory of the data**  |

	@note On Linux/Unix the size and a small padding is stored before the actual data, because **munmap()** requires a size as parameter as well. 

	@section section_category_memory_handling_aligned Custom aligned memory allocation

	@subsection subsection_category_memory_handling_aligned_allocate Allocate custom aligned (n)-bytes of memory

	To allocate a **custom aligned** block of contiguous memory, you simply call @ref fplMemoryAlignedAllocate() with the number of bytes you want to allocate and the custom alignment.<br>
	This will return a guaranteed aligned pointer you can start to write into.

	@code{.c}
	// Allocate a bunch of 4x4 matrices aligned by 16-bytes
	typedef struct Mat4f {
		float m[16];
	} Vec4f;
	Mat4f *matrices = (Mat4f *)fplMemoryAlignedAllocate(sizeof(Mat4f) * 128, 16);
	// ...
	@endcode

	@note The size of the memory block may be greater than the size you requested, due to alignment padding and meta-informations.
	@attention The alignment parameter must be a power-of-two based value, otherwise the function will fail.
	@warning Do not write before this pointer, otherwise you will overwrite meta-informations required for releasing the memory later on.

	@subsection subsection_category_memory_handling_aligned_free Free aligned memory

	To free aligned memory you simply call @ref fplMemoryAlignedFree() with the base pointer of your aligned memory and thats it.

	@warning Do not call this function with a pointer allocated from @ref fplMemoryAllocate() , otherwise you will corrupt memory!

	@subsection subsection_category_memory_handling_aligned_datalayout Data layout of aligned memory

	Here you can see the full data-layout for a aligned memory block:
	
	| 4/8 bytes for x86/x64           | Alignment * 2 bytes   | n-bytes                                                                       |
	|---------------------------------|-----------------------|-------------------------------------------------------------------------------|
	| **Address of the base-pointer** | **Alignment padding** | \ref subsection_category_memory_handling_normal_datalayout "Data layout"      |

	@section section_category_memory_handling_ops Memory operations

	@subsection subsection_category_memory_handling_ops_clear Clear (n)-bytes of memory

	Call @ref fplMemoryClear() to clear a memory block starting from the base-pointer with a given size.

	@code{.c}
	// Clear 4-KB of memory to zero, starting by the given memory address
	fplMemoryClear(myMemory, 4096);

	// or

	// Clear a struct
	fplMemoryClear(myStructPtr, sizeof(*myStructPtr));

	// or

	// Clear a fixed sized array
	fplMemoryClear(myArray, sizeof(myArray));
	@endcode

	@note This operation is executed in 8-bytes, 4-bytes, 2-bytes sized chunks to improve performance.

	@subsection subsection_category_memory_handling_ops_set Overwrite (n)-bytes of memory with a given value

	Call @ref fplMemorySet() to overwrite a memory block starting from the base-pointer with a given size and the given value.

	@code{.c}
	// Overwrites 1000 bytes of memory with a 8-bit value
	fplMemorySet(myMemory, 0xAB, 1000);
	@endcode

	@note This operation is executed in 8-bytes, 4-bytes, 2-bytes sized chunks to improve performance.

	@subsection subsection_category_memory_handling_ops_copy Copy (n)-bytes of memory to another memory location

	To copy (n)-bytes of memory you simply call @ref fplMemoryCopy() with the source and destination pointer and the number of bytes you want to copy.

	@code{.c}
	// Copy parts of memory into another memory
	// void *destMemory was already allocated before
	size_t numberOfBytesToCopy = fplKiloBytes(10);
	fplMemoryCopy(sourceMemory, numberOfBytesToCopy, destMemory);
	@endcode

	@note This operation is executed in 8-bytes, 4-bytes, 2-bytes sized chunks to improve performance.

	@section section_category_memory_handling_macrofuncs Useful macro functions

	FPL provides a few macro functions useful for dealing with memory:<br>
	
	| Name                | What it does                                               |
    |---------------------|------------------------------------------------------------|
	| @ref fplZeroInit    | Initializes a struct with zero                             |
	| @ref fplStructInit  | Initializes a struct with values                           |
	| @ref fplStructSet   | Overwrites a struct with the given value                   |
	| @ref fplClearStruct | Clears the given struct pointer to zero                    |
	| @ref fplCopyStruct  | Copies the source struct data into the destination pointer |
	| @ref fplArrayCount  | Returns the number of elements in fixed sized array        |
	| @ref fplOffsetOf    | Returns the byte-offset to a field in a struct             |
	| @ref fplKiloBytes   | Converts the given kilobytes value into bytes              |
	| @ref fplMegaBytes   | Converts the given megabytes value into bytes              |
	| @ref fplGigaBytes   | Converts the given gigabytes value into bytes              |
	| @ref fplTeraBytes   | Converts the given terabytes value into bytes              |
*/

/*!
	@page page_category_hardware Query Hardware informations
	@tableofcontents

	FPL provides a couple of functions for getting hardware functions, such as CPU core count, name, memory info, etc.<br>

	@section section_category_hardware_corecount Get number of CPU-Cores

	You can retrieve the number of processor cores by calling @ref fplGetProcessorCoreCount() .<br>

	@code{.c}
	size_t coreCount = fplGetProcessorCoreCount();
	// Do something with the core count
	@endcode

	@note Hyperthreads will be included as well, so on a typical 4-core HT CPU this function will return eight cores.

	@section section_category_hardware_cpuarch Get CPU architecture

	You can query the CPU architecture type by calling fplGetProcessorArchitecture() . This will return a @ref fplArchType value which you can use test for certain types.<br>
	<br>
	Use @ref fplGetArchTypeString() to convert a @ref fplArchType into a string.<br>

	@code{.c}
	fplArchType cpuArch = fplGetProcessorArchitecture();
	if (cpuArch == fplArchType_fplArchType_Arm64) {
		// Do something on a ARM-64 CPU
	}

	// or just print it out
	const char *cpuArchString = fplGetArchTypeString(cpuArch);
	fplConsoleFormatOut("CPU Architecture: %s\n", cpuArchString);
	@endcode
	
	@section section_category_hardware_cpuname Get the CPU Name

	You can query the CPU name by calling fplGetProcessorName() .

	@code{.c}
	// Print out the CPU-Name
	char nameBuffer[1024];
	fplGetProcessorName(nameBuffer, fplArrayCount(nameBuffer));
	fplConsoleFormatOut("CPU Name: %s\n", nameBuffer);
	@endcode

	@section section_category_hardware_memstate Query memory state

	With @ref fplGetRunningMemoryInfos() you can query the current memory state.<br>
	This includes the size of the physical memory, the current memory usage and more.<br>
	See @ref fplMemoryInfos for more details.<br>

	@code{.c}
	fplMemoryInfos memInfos = fplZeroInit;
	if (fplGetRunningMemoryInfos(&memInfos)) {
		fplConsoleFormatOut("%llu of %llu physical memory is available.\n", memInfos.freePhysicalSize, memInfos.totalPhysicalSize);
	}
	@endcode
*/

/*!
	@page page_category_ossession Query OS/Session informations
	@tableofcontents

	FPL provides a couple of functions for querying informations about your operating system.

	@section section_category_ossession_osinfos Query OS-Infos (Version, Name, Distribution)

	You can retrieve the version/name of your operating system by calling @ref fplGetOperatingSystemInfos() .<br>
	See @ref fplOSInfos for more details.<br>

	@code{.c}
	fplOSInfos infos = fplZeroInit;
	if (fplGetOperatingSystemInfos(&infos)) {
		fplConsoleFormatOut("Operating system name: %s\n", infos.osName);
		fplConsoleFormatOut("Operating system version: %s.%s.%s.%s\n", infos.osName.major, infos.osName.minor, infos.osName.fix, infos.osName.build);
	}
	@endcode

	@section section_category_ossession_username Get current username

	Use @ref fplGetCurrentUsername() to get the username for the current session.

	@code{.c}
	char usernameBuffer[256];
	if (fplGetCurrentUsername(usernameBuffer, fplArrayCount(usernameBuffer))) {
		fplConsoleFormatOut("Current username: %s\n", usernameBuffer);
	}
	@endcode
*/

/*!
	@page page_category_dll Using Dynamic Libraries
	@tableofcontents

	FPL has built-in support for loading dynamic libraries (.dll/.so).<br>

	@section section_category_dll_load Loading a dynamic library

	To load a dynamic library, such as .dll or .so you simply call @ref fplDynamicLibraryLoad() with the name of the library or the full path.<br>

	@code{.c}
	fplDynamicLibraryHandle libHandle;
	if (fplDynamicLibraryLoad("mylibrary.dll", &libHandle)) {
		// ... using the library

		// Unload it when you are done
		fplDynamicLibraryUnload(&libHandle);
	}
	@endcode

	@note Call @ref fplDynamicLibraryUnload() to unload a loaded library when you are done.

	@section section_category_dll_getprocaddr Getting a procedure address

	To get a procedure address from a function inside a library, simply call @ref fplGetDynamicLibraryProc() .<br>

	@code{.c}
	typedef int(fn_LengthSquared)(int a, int b);
	fplDynamicLibraryHandle libHandle;
	if (fplDynamicLibraryLoad("mymathy.dll", &libHandle)) {
		// Get "LengthSquared" raw procedure address
		void *lenSqFuncRaw = fplGetDynamicLibraryProc(&libHandle, "LengthSquared");

		// Get "LengthSquared" casted procedure address
		fn_LengthSquared *lenSqFunc = (fn_LengthSquared *)fplGetDynamicLibraryProc(&libHandle, "LengthSquared");

		// Use the procedure like any function pointer
		int len = lenSqFunc(3, 6);

		// Unload it when you are done
		fplDynamicLibraryUnload(&libHandle);
	}
	@endcode
*/

/*!
	@page page_category_io_binaryfiles Using Binary Files
	@tableofcontents

	@section section_category_io_binaryfiles_read Reading Files

	@subsection subsection_category_io_binaryfiles_read_open Opening a Binary File

	To open a binary file, simply declare a @ref fplFileHandle somewhere and call fplOpenBinaryFile() with a valid UTF-8 path to open it.<br>

	@code{.c}
	fplFileHandle fileHandle;
	if (fplOpenBinaryFile("myimage.jpg", &fileHandle)) {

		// ... read data

		fplCloseFile(&fileHandle);
	}
	@endcode

	@note Call @ref fplCloseFile() to close a file when you are done.

	@subsection subsection_category_io_binaryfiles_read_readblock Reading from the file

	To read a block of n-bytes from the file starting from the current file position, simply call @ref fplReadFileBlock() with your file handle and a buffer to read into.<br>

	@code{.c}
	struct jpeg_header; // defined somewhere
	fplFileHandle fileHandle;
	if (fplOpenBinaryFile("myimage.jpg", &fileHandle)) {
		size_t read;

		// Read the first 4 characters
		char fourCC[4];
		read = fplReadFileBlock(&fileHandle, 4, fourCC, sizeof(fourCC));
		assert(read == 4);

		// or

		// Read a JPEG-Header
		jpeg_header jpegHeader;
		size_t read;
		read = fplReadFileBlock(&fileHandle, sizeof(jpegHeader), &jpegHeader, sizeof(jpegHeader));
		assert(read == sizeof(jpegHeader));
		fplCloseFile(&fileHandle);
	}
	@endcode

	@section section_category_io_binaryfiles_write Writing Files

	@subsection subsection_category_io_binaryfiles_write_create Creating a Binary File

	To create a binary file, simply declare a @ref fplFileHandle somewhere and call fplCreateBinaryFile() with a valid UTF-8 path to open it.<br>
	If the file already exists, it will be overriden automatically.<br>

	@code{.c}
	fplFileHandle fileHandle;
	if (fplCreateBinaryFile("myimage.jpg", &fileHandle)) {

		// ... write data

		fplCloseFile(&fileHandle);
	}
	@endcode

	@note Call @ref fplCloseFile() to close a file when you are done.

	@subsection subsection_category_io_binaryfiles_write_writeblock Writing to the file

	To write n-bytes of memory into a opened file beginning at the current file position, simply call @ref fplWriteFileBlock() with your file handle and the buffer you want to write.<br>

	@code{.c}
	fplFileHandle fileHandle;
	char *saveGameFilePath = ...
	if (fplCreateBinaryFile(saveGameFilePath, &fileHandle)) {
		char savegameFourCC[4] = {'S', 'A', 'V', 'E'};
		uint8_t *savegameDataPtr = ...;
		size_t savegameDataSize = ...;

		// Write a savegame
		fplWriteFileBlock(&fileHandle, savegameFourCC, 4);
		fplWriteFileBlock(&fileHandle, savegameDataPtr, savegameDataSize);

		fplCloseFile(&fileHandle);
	}
	@endcode

	@section section_category_io_binaryfiles_pos File Position

	@subsection subsection_category_io_binaryfiles_pos_get Getting the current file position

	Call @ref fplGetFilePosition() to get the current file position from a opened @ref fplFileHandle .

	@code{.c}
	fplFileHandle fileHandle = ...
	size_t curPos = fplGetFilePosition(&fileHandle);
	@endcode

	@subsection subsection_category_io_binaryfiles_pos_set Setting the current file position (Seeking)

	Call @ref fplSetFilePosition() to set the current file position on a opened @ref fplFileHandle .<br>

	@code{.c}
	fplFileHandle fileHandle = ...
	// Seek 4-bytes forwards from the current position
	fplSetFilePosition(&fileHandle, 4, fplFilePositionMode_Current);

	// Seek 8-bytes backwards from the current position
	fplSetFilePosition(&fileHandle, -4, fplFilePositionMode_Current);

	// Seek to the 128-byte from the beginning (Absolute seeking)
	fplSetFilePosition(&fileHandle, 128, fplFilePositionMode_Beginning);

	// Seek to the start of the file
	fplSetFilePosition(&fileHandle, 0, fplFilePositionMode_Beginning);

	// Seek to the end of the file (Get file length)
	size_t fileLength = fplSetFilePosition(&fileHandle, 0, fplFilePositionMode_End);
	@endcode

	@section section_category_io_binaryfiles_32vs64 Default vs 32-bit vs 64-bit

	There are three versions for file reading/writing and seekings:<br>
	- A version which uses uint32_t or int32_t (32-bit only, Limited to 2 GB of file = 2^31).<br>
	- A version which uses uint64_t or int64_t (64-bit only, Limited to 2 TB of file = 2^63).<br>
	- A default version which uses size_t or intptr_t always and use either the 32-bit or the 64-bit, depending on the compiled CPU-Architecture.<br>
	<br>
	See the next sections for more details.

	@subsection section_category_io_binaryfiles_32vs64_default Default

	Uses either 32-bit or the 64-bit, depending on the compiled CPU architecture:<br>
	- @ref fplSetFilePosition() maps to @ref fplSetFilePosition32() or fplSetFilePosition64()
	- @ref fplGetFilePosition() maps to @ref fplSetFilePosition32() or fplSetFilePosition64()
	- @ref fplReadFileBlock() maps to @ref fplReadFileBlock32() or fplReadFileBlock64()
	- @ref fplWriteFileBlock() maps to @ref fplWriteFileBlock32() or fplWriteFileBlock64()
	- @ref fplGetFileSizeFromPath() maps to @ref fplGetFileSizeFromPath32() or fplGetFileSizeFromPath64()
	- @ref fplGetFileSizeFromHandle() maps to @ref fplGetFileSizeFromHandle32() or fplGetFileSizeFromHandle64()
	
	@subsection section_category_io_binaryfiles_32vs64_32 32-bit

	Limited to 32-bit:<br>
	- @ref fplSetFilePosition32()
	- @ref fplSetFilePosition32()
	- @ref fplReadFileBlock32()
	- @ref fplWriteFileBlock32()
	- @ref fplGetFileSizeFromPath32()
	- @ref fplGetFileSizeFromHandle32()

	@subsection section_category_io_binaryfiles_32vs64_64 64-bit

	Up to 2-TB (64-bit):<br>
	- @ref fplSetFilePosition64()
	- @ref fplSetFilePosition64()
	- @ref fplReadFileBlock64()
	- @ref fplWriteFileBlock64()
	- @ref fplGetFileSizeFromPath64()
	- @ref fplGetFileSizeFromHandle64()
*/

/*!
	@page page_category_io_paths Working with Paths/Files
	@tableofcontents

	@section section_category_io_paths_constants Path constants

	FPL provides a couple of path constants you can use, if needed:<br>
	| Name | Description |
	|-|-|
	| @ref FPL_MAX_PATH_LENGTH | Defines the maximum length of any path|
	| @ref FPL_MAX_FILENAME_LENGTH | Defines the maximum length of a single filename without path|
	| @ref FPL_PATH_SEPARATOR | Defines the path separator character|
	| @ref FPL_FILE_EXT_SEPARATOR | Defines the file extension separator character|

	@note All length constants includes the null-terminator character as well, so you dont have to add one to the length when using!

	@section section_category_io_paths_utils Utilities

	@subsection subsection_category_io_paths_utils_pathcombine Combining paths

	Use @ref fplPathCombine() to combine multiple parts of a path to build one single path from it.<br>
	Unlike the .NET version, this function requires you pass the number of parts you want to combine :-( If you know how get the number of variadic arguments (va_list) in C99, please contact me or write a github issue! Thanks.<br>

	<b>Example:</b>
	@code{.c}
	const char *assetsRootPath = ...
	char textureAssetFilePath[FPL_MAX_PATH_LENGTH];
	if (fplPathCombine(textureAssetFilePath, fplArrayCount(textureAssetFilePath), 3, assetsRootPath, "textures", "mytexture.png") != fpl_null) {
		// ... Do something with the textureAssetFilePath
	}

	char tempPath[1024];
	fplPathCombine(tempPath, fplArrayCount(tempPath), 3, "One", "Another", "Last");
	// POSIX tempPath = One/Another/Last
	// Win32 tempPath = One\Another\Last
	@endcode

	@note This is the recommend way to construct any kind of paths, because it will handle path separators correctly.
	@note This function is designed to be compatible with .NET <b>Path.Combine()</b>.
	@warning Do not pass the wrong number of maximum arguments as third-argument, otherwise your application may end crash horribly.

	@subsection subsection_category_io_paths_utils_extractfilepath Extracting the file path

	Use @ref fplExtractFilePath() to extract the directory from the given path.<br>
	<br>
	Using this on a path with a file will extract the path where the file is stored.<br>
	Using this on a directory path will extract the path of the parent directory.<br>

	<b>Example:</b>
	@code{.c}
	const char *inputPath = ...
	char newPath[FPL_MAX_PATH_LENGTH];
	if (fplExtractFilePath(inputPath, &newPath, fplArrayCount(newPath)) != fpl_null) {
		// ... Do something with the newPath
	}
	@endcode

	@note This function is designed to be compatible with .NET <b>Path.GetDirectoryName()</b> or <b>ExtractFilePath()</b> on Delphi/FreePascal.<br>
	@note The original path is not altered in any way, therefore the source argument is defined as const.
	@warning Do not use manually constructed source paths with fixed path separators such as <b>/</b> or <b>\\</b>, otherwise you will lose platform independence! Use @ref fplPathCombine() to build new paths from multiple paths if needed.
	@warning The return value of @ref fplExtractFilePath returns the pointer to the last-written character and <b>NOT</b> the pointer to the first character!

	@subsection subsection_category_io_paths_utils_extractfilename Extracting the file name

	Use @ref fplExtractFileName() to extract the filename from any path.<br>
	Using this on a full or relative file-path will extract the name of the file.<br>
	Using this on a directory path will extract the name of the last directory in the path.<br>

	<b>Example:</b>
	@code{.c}
	const char *inputFilePath = ...
	const char *fileName = fplExtractFileName(inputFilePath);

	// ... Do something with the fileName

	// Results:
	// /my/path/to/the/file.ico -> file.ico
	// /my/path/to/the/starting.file.ico -> starting.file.ico
	// c:\Program Files (x86)\Xenorate\Xenorate.exe -> Xenorate.exe
	// myAwesomeFilename.executable -> myAwesomeFilename.executable
	// passthrough -> passthrough
	// /my/path/to/the/ -> 
	@endcode

	@note This function is designed to be compatible with .NET <b>Path.GetFileName()</b> or <b>ExtractFileName()</b> on Delphi/FreePascal.<br>
	@note The original path is not altered in any way, therefore the source argument is defined as const.
	@warning Do not use manually constructed source paths with fixed path separators such as <b>/</b> or <b>\\</b>, otherwise you will lose platform independence! Use @ref fplPathCombine() to build new paths from multiple paths if needed.

	@subsection subsection_category_io_paths_utils_extractfileext Extracting the file extension

	Use @ref fplExtractFileExtension() to extract the file extension from a path.<br>
	This will return anything starting from the last found file extension separator @ref FPL_FILE_EXT_SEPARATOR to the very end of path - containing the starting dot.<br>
	Using this on a path or filename will get you just the file extension, if there is any.<br>

	<b>Example:</b>
	@code{.c}
	const char *inputFilePath = ...
	const char *fileExt = fplExtractFileExtension(inputFilePath);

	// ... Do something with the fileExt

	// Results:
	// /my/path/to/the/file.ico -> .ico
	// /my/path/to/the/starting.file.ico -> .file.ico
	// c:\Program Files (x86)\Xenorate\Xenorate.exe -> .exe
	// myAwesomeFilename.executable -> .executable
	// /my/path/what.ever/libMyAwesome.so -> .so
	// i_dont_have_any_dots_in_the_name -> 
	@endcode

	@note This function is designed to be compatible with .NET <b>Path.GetExtension()</b> or <b>ExtractFileExt()</b> on Delphi/FreePascal.<br>
	@note The original path is not altered in any way, therefore the source argument is defined as const.
	@warning Do not use manually constructed source paths with fixed path separators such as <b>/</b> or <b>\\</b>, otherwise you will lose platform independence! Use @ref fplPathCombine() to build new paths from multiple paths if needed.

	@subsection subsection_category_io_paths_utils_changefileext Changing the file extension

	Use @ref fplChangeFileExtension() to change/add a file extensions on a file path.<br>

	<b>Example:</b>
	@code{.c}
	const char *inputFilePath = ...
	char changedFileExt[FPL_MAX_PATH_LENGTH];
	if (fplChangeFileExtension(inputFilePath, ".log", changedFileExt, fplArrayCount(changedFileExt)) != fpl_null) {
		// ... Do something with the changedFileExt
	}
	@endcode

	@note This function is designed to be compatible with .NET <b>Path.ChangeFileExtension()</b>.<br>
	@note The original path is not altered in any way, therefore the source arguments are defined as const.
	@warning Do not use manually constructed source paths with fixed path separators such as <b>/</b> or <b>\\</b>, otherwise you will lose platform independence! Use @ref fplPathCombine() to build new paths from multiple paths if needed.

	@section section_category_io_paths_get Retrievement of paths

	@subsection subsection_category_io_paths_get_home Getting the home directory path

	Use @ref fplGetHomePath() to retrieve the home directory path for the current user.<br>
	<br>
	On a POSIX based system this will most likely return something like <b>&quot;/usr/home/the_username_in_question&quot;</b><br>
	On a Win32 based system this will most likely return something like <b>&quot;c:\\Users\\TheUsernameInQuestion&quot;</b><br>

	<b>Example:</b>
	@code{.c}
	char homePath[FPL_MAX_PATH_LENGTH];
	fplGetHomePath(&homePath, fplArrayCount(homePath));
	// ... Do something with the homePath
	@endcode

	@note There is no guarantee that this path ends with a trailing path separator, such as <b>/</b> on POSIX or <b>\\</b> on Win32! If needed use @ref fplEnforcePathSeparator to force a path separator on always.
	@warning The return value of @ref fplGetHomePath returns the pointer to the last-written character and <b>NOT</b> the pointer to the first character!

	@subsection subsection_category_io_paths_get_exepath Get executable file path

	Use @ref fplGetExecutableFilePath() to retrieve the full-path to your current executable.<br>
	<br>
	On a POSIX based system this will most likely return something like <b>&quot;/some/path/../my_application&quot;</b><br>
	On a Win32 based system this will most likely return something like <b>&quot;c:\\Some\\Path\\..\\MyApplication.exe&quot;</b><br>

	<b>Example:</b>
	@code{.c}
	// Get executable file path
	char exeFilePath[FPL_MAX_PATH_LENGTH];
	fplGetExecutableFilePath(&exeFilePath, fplArrayCount(exeFilePath));

	// Get executable directory path
	char appPath[FPL_MAX_PATH_LENGTH];
	if (fplExtractFilePath(exeFilePath, &appPath, fplArrayCount(appPath)) != fpl_null) {
		// ... Do something with appPath
	}
	@endcode

	@note There is no guarantee that this path ends with a trailing path separator, such as <b>/</b> on POSIX or <b>\\</b> on Win32! If needed use @ref fplEnforcePathSeparator to force a path separator on always.
	@note The name of the executable is always included in the path and will contain the file extension, if there is one.
	@warning The return value of @ref fplExtractFilePath returns the pointer to the last-written character and <b>NOT</b> the pointer to the first character!

	@section section_category_io_paths_traversing Directory Traversing

	FPL provides a powerful and easy directory traversal api, to find either files, directories or both using a wildcard matching system.

	@subsection subsection_category_io_paths_traversing_findfiles Finding files by wildcard

	Use @ref fplListDirBegin() to start finding files in a path.<br>
	If this function succeeds, the result for the first match is written into the @ref fplFileEntry structure.<br>
	<br>
	After this you repeatly call @ref fplListDirNext(), to get the next match into @ref fplFileEntry structure - until the function returns false.<br>

	<b>Example:</b>
	@code{.c}
	const char *sourcePath = ...
	fplFileEntry fileEntry;
	size_t fileCount = 0;

	// Find all .so files (For-loop style)
	fileCount = 0;
	for(bool hasEntry = fplListDirBegin(sourcePath, "*.so", &entry); hasEntry; hasEntry = fplListDirNext(&entry)) {
		// ... do something with entry.name
		++fileCount;
	}

	// Find all .so files (While style)
	fileCount = 0;
	if (fplListDirBegin(sourcePath, "*.so", &entry)) {
		// The first file was found
		// ... do something with entry.name
		++fileCount;

		// Loop until no file is found
		while (fplListDirNext(&entry)) {
			// ... do something with entry.name
			++fileCount;
		}
	}

	// Find all .so files (For-loop style, break out after reaching a limit of maximum allowed files)
	size_t maxFileCount = ...
	fileCount = 0;
	for(bool hasEntry = fplListDirBegin(sourcePath, "*.so", &entry); hasEntry; hasEntry = fplListDirNext(&entry)) {
		if (fileCount < maxFileCount) {
			// ... do something with entry.name
		} else {
			// Release resources, when we exit out the iteration
			fplListDirEnd(&entry);
			break;
		}
		++fileCount;
	}
	@endcode

	@note When @ref fplListDirBegin or @ref fplListDirNext does not find any match, the internal resources are released automatically.
	@warning If you manually stop the iteration, please call @ref fplListDirEnd() to release its internal resources - otherwise you may leak memory!

	@subsection subsection_category_io_paths_traversing_traversefiles Recursively get all files in a directory

	There is no recursion support built-in in FPL, but you can easily make one using @ref fplListDirBegin() .<br>
	Just iterate through the file entries, which are already explained in here: @ref subsection_category_io_paths_traversing_findfiles <br>
	You can check @ref fplFileEntry.type ,to check for either a @ref fplFileEntryType_Directory or a @ref fplFileEntryType_File type to start a recursion or not.<br>

	<b>Example:</b>
	@code{.c}

	// Some existing awesome file-list container api
	typedef struct file_list_t {
		size_t capacity;
		size_t count;
		char **items;
	} file_list_t;
	void init_file_list(file_list_t *outList);
	void free_file_list(file_list_t *outList);
	void push_file_list_item(file_list_t *outList, const char *item);

	static void GetFilesFromDirectory(const char *rootPath, const bool recursive, file_list_t *outList) {
		fplEntry entry;
		for(bool hasEntry = fplListDirBegin(rootPath, "*", &entry); hasEntry; hasEntry = fplListDirNext(&entry)) {
			char path[FPL_MAX_PATH_LENGTH];
			fplPathCombine(path, fplArrayCount(path), 2, rootPath, entry.name);
			if (entry.type == fplFileEntryType_Directory && recursive) {
				GetFilesFromDirectory(path, true, outList);
			} else if (entry.type == fplFileEntryType_File) {
				push_file_list_item(outList, path);
			}
		}
		return(result);
	}

	int main(int argc, char **argv) {
		if (argc < 2) {
			return 1; 
		}
		const char *rootPath = argv[1];
		file_list_t outFileList;
		init_file_list(&outFileList);
		GetFilesFromDirectory(rootPath, true, &outFileList);
		// ... do someting with out file list
		free_file_list(&outFileList);
		return 0;
	}
	@endcode
*/

/*!
	@page page_category_threading_threads Threads
	@tableofcontents

	@section section_category_threading_threads_overview Overview
	In this section you will learn the Basics about creating and handling of Threads.<br>
	With Threads you can run multiple pieces of Code in parallel.<br>
	Threads require the use of @subpage page_category_threading_sync to prevent race conditions.

	@section section_category_threading_threads_create Creating a Thread
	Call @ref fplThreadCreate() with a pointer to @ref fpl_run_thread_callback "callback" and a user pointer argument, to create and immediately run a Thread.<br>

    @code{.c}
    void MyThreadProc(const fplThreadHandle *context, void *data) {
        // ... do something here
    }
    void RunMyThread() {
        int myData = 42;
        fplThreadHandle *thread = fplThreadCreate(MyThreadProc, &myData);
        fplThreadWaitForOne(thread, FPL_TIMEOUT_INFINITE);
    }
    @endcode

	@note The internal Thread resources will be cleaned up automatically after your code has finished running.<br>
	@warning When a Thread has finished running, you cannot use the same @ref fplThreadHandle anymore -> It may be reassigned to another Thread in the future.<br>

	@section section_category_threading_threads_destroy Destroying a Thread?
	You don't have to manually release the Thread resources, this will be cleaned up automatically when either the Thread ends naturally or when it was terminated forcefully using @ref fplThreadTerminate() .
	<br>
	@warning Do not call @ref fplThreadTerminate() to stop or release a Thread! Let the thread exit naturally.

	@section section_category_threading_threads_wait Waiting/Joining for Threads to Exit

	@subsection subsection_category_threading_threads_wait_single Wait for a single Thread to Exit
	Call @ref fplThreadWaitForOne() with a pointer to @ref fplThreadHandle and a @ref fplTimeoutValue argument, to wait for a single Thread to finish.

	@code{.c}
	// Wait until the thread is finished
	fplThreadWaitForOne(thread, FPL_TIMEOUT_INFINITE);

	// ... or

	// Wait at max for 5 seconds to finish the thread
	fplThreadWaitForOne(thread, 5000);
    @endcode

	@subsection subsection_category_threading_threads_wait_any Wait for any Thread to Exit
	Call @ref fplThreadWaitForAny() with an array of @ref fplThreadHandle, the number of threads and a @ref fplTimeoutValue argument to wait until at least one Thread had finished.

	@code{.c}
	// Wait until one of the threads is finished
	fplThreadWaitForAny(threads, numOfThreads, FPL_TIMEOUT_INFINITE);

	// ... or

	// Wait at max for 5 seconds to finish at least one of the threads
	fplThreadWaitForAny(threads, numOfThreads, 5000);
    @endcode

	@subsection subsection_category_threading_threads_wait_all Wait for all Threads to Exit
	Call @ref fplThreadWaitForAll() with an array of @ref fplThreadHandle , the number of threads and a @ref fplTimeoutValue argument, to wait for all Threads to be finished.

	@code{.c}
	// Wait until all of the threads are finished
	fplThreadWaitForAll(threads, numOfThreads, FPL_TIMEOUT_INFINITE);

	// ... or

	// Wait at max for 5 seconds to finish all threads
	fplThreadWaitForAll(threads, numOfThreads, 5000);
    @endcode

	@section section_category_threading_threads_terminate Terminate a thread
	Call @ref fplThreadTerminate() with a pointer to @ref fplThreadHandle as argument, to forcefully terminate a thread.
	@note Using this will almost immediately terminates the thread and releases its resources.
	@note It is safe to call this when a thread is already terminated.

	@section section_category_threading_threads_states Query the Thread State
	Call @ref fplGetThreadState() with a pointer to @ref fplThreadHandle as argument, to query the current state.<br>
	If a thread is stopped or in the process of getting stopped it will return @ref fplThreadState_Stopped or @ref fplThreadState_Stopping respectively.<br>
	If a thread is started or in the process of getting started it will return @ref fplThreadState_Running or @ref fplThreadState_Starting respectively.<br>

	@section section_category_threading_threads_notes Notes
	@note Your code should always ensure that it will exit eventually. You can use @subpage page_category_threading_sync to achieve this.<br>
	@note It is bad practice to "Terminate" a thread, you should design your code to let threads end naturally.
*/

/*!
	@page page_category_threading_mutexes Mutexes
	@tableofcontents

	@section section_category_threading_mutexes_overview Overview
	This section explains how to create and handling of Mutexes.<br>
	A mutex is a Kernel-Level object used to prevent race conditions when multiple Threads access the same code section.<br>
	With a Mutex you can ensure that only one thread at a time can access a code section.

	@section section_category_threading_mutexes_init Initialize a Mutex
	Call @ref fplMutexInit() with a pointer to @ref fplMutexHandle argument, to initialize a Mutex.<br>
	After the initialization is done, you can start locking and unlocking it.<br>
	When you are done with the Mutex call @ref fplMutexDestroy() to release its internal resources.

	@code{.c}
	fplMutexHandle mutex;
	if (!fplMutexInit(&mutex)) {
	    // Error: Mutex failed initializing -> Too many active mutexes for this process or already initialized
	}

	// ... Mutex is not required anymore
	fplMutexDestroy(&mutex);
    @endcode

	@section section_category_threading_mutexes_locking Locking/Unlocking a Mutex

	@subsection subsection_category_threading_mutexes_locking_lock Locking a Mutex
	Call @ref fplMutexLock() with a pointer to @ref fplMutexHandle as argument, to lock a Mutex.<br>
	It this Mutex is already locked, the current Thread will wait forever until it gets unlocked by the owner Thread.<br>
	If this Mutex is not locked yet, it will be locked by the calling Thread.<br>

	@note You should always unlock the @ref fplMutexHandle as soon as possible - on the same call stack.<br>

	@subsection subsection_category_threading_mutexes_locking_unlock Unlocking a Mutex
	Call @ref fplMutexUnlock() with a pointer to @ref fplMutexHandle as argument, to unlock a Mutex.<br>
	The Mutex will be unlocked only when this function is called from the owner Thread.<br>
	If this Mutex was not locked or the owner Thread does not match it will fail.

	@subsection subsection_category_threading_mutexes_locking_probe Trying to lock a Mutex
	Call @ref fplMutexTryLock() with a pointer to @ref fplMutexHandle as argument, to try to lock a Mutex.<br>
	If the Mutex is already locked, the current Thread will not be blocked and the function returns false.<br>
	If this Mutex is not locked yet, it will be locked by the calling Thread.<br>

    @subsection subsection_category_threading_mutexes_locking_example Example

	@code{.c}
	// Lock down the execution of a code section to one Thread at a time
	fplMutexLock(&mutex);
	{
	    // Do something in this critical section here
	}
	fplMutexUnlock(&mutex);

	// Locking a mutex can fail, so ensure that you check the result
	if (fplMutexLock(&mutex)) {
    	// Do something in this critical section here
	    fplMutexUnlock(&mutex);
	}

	// Dont wait for the mutex to be unlocked, just try to lock it
	if (fplMutexTryLock(&mutex)) {
    	// Do something in this critical section here
	    fplMutexUnlock(&mutex);
	}
    @endcode

    @note It is recommended to put a opening/closing brace to mark the code inside the lock as critical code.
*/

/*!
	@page page_category_threading_signals Signals
	@tableofcontents

	@section section_category_threading_signals_overview Overview
	This section explains how to create and manage Signals.<br>
	A Signal is a Kernel-Level object used to notify one or multiple waiting Threads.<br>
	It internally contains a Value which is either @ref fplSignalValue_Set or @ref fplSignalValue_Unset.<br>
	When this value gets changed, all Threads which waits on that Signal will wakeup.<br>
	They can be shared across process boundaries and may be used as standalone locks to shared data, but the number of Signals are limited by the OS that can be allocated at a time.

	@section section_category_threading_signals_init Initialize a Signal
	Call @ref fplSignalInit() with a pointer to @ref fplSignalHandle as an argument, to initialize a Signal.<br>
	Also, you need to specify if the Signal starts as @ref fplSignalValue_Set or @ref fplSignalValue_Unset as a second argument.<br>
	When you are done with that Signal, you need to call @ref fplSignalDestroy() to release its internal resources.

	@code{.c}
	fplSignalHandle mutex;
	// Initialize a Signal as "unset"
	if (!fplSignalInit(&mutex, fplSignalValue_Unset)) {
	    // Error: Signal failed initializing -> Too many active Signals
	}

	// ... Signal is not required anymore
	fplSignalDestroy(&mutex);
    @endcode

	@section section_category_threading_signals_wait Waiting for Signal

	@subsection subsection_category_threading_signals_wait_single Wait for a single Signal to be set
	Call @ref fplSignalWaitForOne() with a pointer to @ref fplSignalHandle and a @ref fplTimeoutValue argument, to let the current Thread wait until the Signal is set.

	@code{.c}
	// Wait until the Signal is set
	fplSignalWaitForOne(thread, FPL_TIMEOUT_INFINITE);

	// ... or

	// Wait at max for 5 seconds or until the Signal is set
	fplSignalWaitForOne(thread, 5000);
    @endcode

	@subsection subsection_category_threading_signals_wait_any Wait for any Signal to be set
	Call @ref fplSignalWaitForAny() with an array of @ref fplSignalHandle, the number of Signals and a @ref fplTimeoutValue argument, to let the current Thread wait until at least one Signal is set.

	@code{.c}
	// Wait until one of the Signal is set
	fplSignalWaitForAny(signals, numOfSignals, FPL_TIMEOUT_INFINITE);

	// ... or

	// Wait at max for 5 seconds or until one of the Signal is set
	fplSignalWaitForAny(signals, numOfSignals, 5000);
    @endcode

	@subsection subsection_category_threading_signals_wait_all Wait for all Signals to be set
	Call @ref fplSignalWaitForAll() with an array of @ref fplSignalHandle , the number of Signals and a @ref fplTimeoutValue argument, to let the current Thread wait until all Signals are set.

	@code{.c}
	// Wait until all of the Signals are set
	fplSignalWaitForAll(signals, numOfSignals, FPL_TIMEOUT_INFINITE);

	// ... or

	// Wait at max for 5 seconds or until all of the Signal are set
	fplSignalWaitForAll(signals, numOfSignals, 5000);
    @endcode

	@section section_category_threading_signals_set Setting a Signal

	Call @ref fplSignalSet() with a pointer to @ref fplSignalHandle as argument, to set a Signal and wakeup all waiting Threads.<br>
	@note Unlike @ref fplConditionVariable , setting a Signal is not Thread-Safe so you should ensure that only one Thread at a time will set it!

	@code{.c}
	// Use a mutex or another synchronisation method to ensure that only one Thread can set the Signal
	fplMutexLock(&mutex);
	fplSignalSet(signal);
	fplMutexUnlock(&mutex);
    @endcode

	@section section_category_threading_signals_reset Resetting a Signal
	Call @ref fplSignalReset() with a pointer to @ref fplSignalHandle as argument, to reset a Signal.<br>
	@note Unlike @ref fplConditionVariable , resetting a Signal is not Thread-Safe so you should ensure that only one Thread at a time will set it!

	@code{.c}
	// Use a mutex or another synchronisation method to ensure that only one Thread can reset the Signal
	fplMutexLock(&mutex);
	fplSignalReset(signal);
	fplMutexUnlock(&mutex);
    @endcode
*/

/*!
	@page page_category_threading_conditions Condition-Variables
	@tableofcontents

	@section section_category_threading_conditions_overview Overview
	This section explains how to create and handling of Condition-Variables.<br>
	A Condition-Variable is a User-Level Object used to let Threads wait until a Condition-Variable is signaled or broadcasted.<br>
	Unlike @subpage page_category_threading_signals, Condition-Variables requires you to use a @ref fplMutexHandle as a locking mechanism.<br>
	They cannot be shared across process boundaries but the number of Condition-Variables is only limited by the amount of memory you have.

	@section category_threading_conditions_init Initialize a Condition-Variable
	Call @ref fplConditionInit() with a pointer to @ref fplConditionVariable as an argument, to initialize a Condition-Variable.<br>
	When you are done with that Condition-Variable, you need to call @ref fplConditionDestroy() to release its internal resources.

	@code{.c}
	fplConditionVariable condition;
	if (!fplConditionInit(&condition)) {
	    // Error: Condition-Variable failed initializing -> This will most likely never happen
	}

	// ... Condition-Variable is not required anymore
	fplConditionDestroy(&condition);
    @endcode

	@section category_threading_conditions_wait_single Waiting on a Condition-Variable
	Call @ref fplConditionWait() with a pointer to @ref fplConditionVariable and a pointer to @ref fplMutexHandle as argument, to let a thread wait on that Condition-Variable.<br>
	Also, you need to specify the amount of milliseconds you want the Thread to wait. If **FPL_TIMEOUT_INFINITE** is passed, it will wait forever.<br>
	@note Conditions must be called inside a locked critical-section or undefined behavior may happen.

	@code{.c}
	fplMutexLock(&mutex);
	{
		// Wait until the Condition-Variable is signaled or broadcasted
		fplConditionWait(&condition, &mutex, FPL_TIMEOUT_INFINITE);

		// ... or

		// Wait at max for 5 seconds for a signal or broadcast on the Condition-Variable
		fplConditionWait(&condition, &mutex, 5000);
	}
	fplMutexUnlock(&mutex);
    @endcode

	@section category_threading_conditions_wait_multiple Waiting on multiple Condition-Variables?
	A Thread can only wait on one single Condition-Variable at a time - if you need to wait on multiple Condition-Variables, you should consider using @subpage page_category_threading_signals .

	@section category_threading_conditions_signal Send a Signal to a Condition-Variable to one waiting Thread
	Call @ref fplConditionSignal() with a pointer to @ref fplConditionVariable, to signal any waiting Threads.<br>
	If you want to let multiple Threads waits on the same Condition-Variable, use @ref fplConditionBroadcast() instead.<br>
	@note Unlike Signals Condition-Variables does not need a Mutex for signaling.

	@code{.c}
	// Send a Signal to the Condition-Variable to one waiting Thread
	fplConditionSignal(&cond);
    @endcode

	@section category_threading_conditions_broadcast Send a Condition-Variable Broadcast to all waiting Threads
	Call @ref fplConditionBroadcast() with a pointer to @ref fplConditionVariable, to signal all waiting Threads.<br>
	If you just need a single Thread to wait on the Condition-Variable, use @ref fplConditionSignal() instead.<br>
	@note Unlike Signals Condition-Variables does not need a Mutex for signaling a Condition-Variable.

	@code{.c}
	// Broadcast a Signal to the Condition-Variable to all waiting Threads
	fplConditionBroadcast(&cond);
    @endcode
*/

/*!
	@page page_category_threading_semaphores Semaphores
	@tableofcontents

	@section section_category_threading_semaphores_overview Overview
	This section explains how to create and manage semaphores.<br>
	Semaphores are similar to @subpage page_category_threading_mutexes "Mutexes" but has one major difference: Any Thread can release it!<br>
	It internally uses an atomic counter which gets incremented and decremented.

	@section category_threading_semaphores_init Initialize a Semaphore
	Call @ref fplSemaphoreInit() to initialize a Semaphore with a @ref fplSemaphoreHandle as an argument. In addition you need to specify the initial value for the Semaphore to start with.<br>
	Call @ref fplSemaphoreDestroy() when you are done with that Semaphore to let it releases its internal resources.

	@code{.c}
	fplSemaphoreHandle semaphore;
	if (!fplSemaphoreInit(&semaphore, 1)) {
	    // Error: Semaphore failed initializing -> This will most likely never happen
	}

	// ... Semaphore is not required anymore and no threads are waiting on it
	fplSemaphoreDestroy(&semaphore);
    @endcode

	@section category_threading_semaphores_wait Waiting/Locking a Semaphore
	Call @ref fplSemaphoreWait() to let a Thread wait and decrement the Semaphores value with a @ref fplSemaphoreHandle as argument.<br>
	If the Semaphores value is greater than zero, then the decrement will happen and the function returns immediatly.<br>
	If the Semaphores value is zero then the Thread will wait until it is possible to decrement the value.<br>
	Also, you need to specify the amount of milliseconds you want the thread to wait. If FPL_TIMEOUT_INFINITE is passed, it will wait forever.<br>

	@code{.c}
	// Wait until the Semaphores value is > 0
	fplSemaphoreWait(&semaphore, FPL_TIMEOUT_INFINITE);

	// ... or

	// Wait at max for 5 seconds to the Semaphores value to be > 0
	fplSemaphoreWait(&semaphore, 5000);
    @endcode

	@section category_threading_semaphores_wait_multiple Waiting on multiple Semaphores?
	A thread can only wait on one single Semaphore at a time - if you need to wait on multiple Semaphores, you should consider using @subpage page_category_threading_signals .

	@section subsection_category_threading_semaphores_trywait Trying to wait on a Semaphore
	@ref fplSemaphoreTryWait() is the same as @ref fplSemaphoreWait() , except that if the decrement cannot immediately perform, the current Thread will not be _blocked_.

	@section category_threading_semaphores_post Releasing the Semaphore
	Call @ref fplSemaphoreRelease() with the @ref fplSemaphoreHandle in question, to release a Semaphore and signal all waiting Threads.<br>	 

	@code{.c}
	// Release a Semaphore and signal all waiting Threads
	fplSemaphoreRelease(&semaphore);
    @endcode

	@section category_threading_semaphores_getvalue Reading the Value from the Semaphore
	Call @ref fplSemaphoreValue() to get the current value from the Semaphore.

	@code{.c}
	int32_t currentValue = fplSemaphoreValue(&semaphore);

	// ... do something with the value here
    @endcode
*/

/*!
	@page page_category_threading_atomics Atomics
	@tableofcontents

	@section category_threading_atomics_overview Overview
	This section explains what atomics is and how they are used.<br>
	Since decades CPUs have hardware CPU instructions for doing thread-safe math and compare operations built-in.<br>
	These instructions are available as built-in intrinsics in any modern C/C++ compiler.<br>
	In FPL these are called Atomics and are wrapper functions around those intrinsics.<br>
	<br>
	Atomics functions generate memory barriers (or fences) to ensure that memory operations are completed in order.

	@section category_threading_atomics_add Fetch-And-Add (Add)
	With a Fetch-And-Add instruction you can do an atomic addition and get the previous value **before** the add back as an atomic operation.<br>

	Pseudo code:
	@code
	oldValue = *storageValue;
	*storageValue = oldValue + inc;
	return oldValue;
	@endcode

	FPL have several versions for that for various datatypes:
	- @ref fplAtomicFetchAndAddU32()
	- @ref fplAtomicFetchAndAddU64()
	- @ref fplAtomicFetchAndAddS32()
	- @ref fplAtomicFetchAndAddS64()
	- @ref fplAtomicFetchAndAddSize()
	- @ref fplAtomicFetchAndAddPtr()

	Usage:
	@code{.c}
	volatile uint32_t storageValue;
	uint32_t oldValue = fplAtomicFetchAndAddU32(&storageValue, 7);
	@endcode

	@section category_threading_atomics_inc Add-And-Fetch (Increment)
	With a Add-And-Fetch instruction you can do an atomic addition by **one** and get the new value back **after** the increment as an atomic operation.<br>
	
	Pseudo code:
	@code
	*StorageValue++;
	NewValue = *StorageValue;
	return newValue;
	@endcode

	FPL have several versions for that for various datatypes:
	- @ref fplAtomicAddAndFetchU32()
	- @ref fplAtomicAddAndFetchU64()
	- @ref fplAtomicAddAndFetchS32()
	- @ref fplAtomicAddAndFetchS64()
	- @ref fplAtomicAddAndFetchSize()
	- @ref fplAtomicAddAndFetchPtr()

	Usage:
	@code{.c}
	volatile uint32_t storageValue;
	uint32_t newValue = fplAtomicAddAndFetchU32(&storageValue);
	@endcode

	@section category_threading_atomics_exchange Exchange
	With a Exchange instruction you can do an atomic exchange and get the previous value back **before** the change as an atomic operation.<br>
	
	Pseudo code:
	@code
	oldValue = *storageValue;
	*storageValue = exchangeValue;
	return oldValue;
	@endcode

	FPL have several versions for that for various datatypes:
	- @ref fplAtomicExchangeU32()
	- @ref fplAtomicExchangeU64()
	- @ref fplAtomicExchangeS32()
	- @ref fplAtomicExchangeS64()
	- @ref fplAtomicExchangeSize()
	- @ref fplAtomicExchangePtr()

	Usage:
	@code{.c}
	volatile uint32_t storageValue;
	uint32_t newValue = fplAtomicStoreU32(&storageValue, 1337);
	@endcode

	@note The exchange atomics is identical to @ref category_threading_atomics_store, except that the exchange atomics will return the previous value before the change.

	@section category_threading_atomics_store Store
	With a Store instruction you can do a memory write as an atomic operation.<br>
	
	Pseudo code:
	@code
	*storageValue = newValue;
	@endcode

	FPL have several versions for that for various datatypes:
	- @ref fplAtomicStoreU32()
	- @ref fplAtomicStoreU64()
	- @ref fplAtomicStoreS32()
	- @ref fplAtomicStoreS64()
	- @ref fplAtomicStoreSize()
	- @ref fplAtomicStorePtr()

	Usage:
	@code{.c}
	volatile uint32_t storageValue;
	fplAtomicStoreU32(&storageValue, 1337);
	@endcode

	@note The store atomics is identical to @ref category_threading_atomics_exchange, except that the store atomics wont return any value.

	@section category_threading_atomics_load Load
	With a Load instruction you can do a memory read as an atomic operation.<br>
	
	Pseudo code:
	@code
	return *storageValue;
	@endcode

	FPL have several versions for that for various datatypes:
	- @ref fplAtomicLoadU32()
	- @ref fplAtomicLoadU64()
	- @ref fplAtomicLoadS32()
	- @ref fplAtomicLoadS64()
	- @ref fplAtomicLoadSize()
	- @ref fplAtomicLoadPtr()

	Usage:
	@code{.c}
	volatile uint32_t storageValue;
	uint32_t value = fplAtomicLoadU32(&storageValue);
	@endcode

	@section category_threading_atomics_cas Compare-And-Swap
	With a Compare-And-Swap instruction you can check a value against another and exchange them as an atomic operation.<br>
	The previous/current value will always be returned regardless of the result.<br>

	Pseudo code:
	@code
	oldValue = *storageValue;
	if (oldValue == comparend) {
		*storageValue = exchangeValue;
	}
	return oldValue;
	@endcode

	FPL have several versions for that for various datatypes:
	- @ref fplAtomicCompareAndSwapU32()
	- @ref fplAtomicCompareAndSwapU64()
	- @ref fplAtomicCompareAndSwapS32()
	- @ref fplAtomicCompareAndSwapS64()
	- @ref fplAtomicCompareAndSwapSize()
	- @ref fplAtomicCompareAndSwapPtr()
	- @ref fplIsAtomicCompareAndSwapU32()
	- @ref fplIsAtomicCompareAndSwapU64()
	- @ref fplIsAtomicCompareAndSwapS32()
	- @ref fplIsAtomicCompareAndSwapS64()
	- @ref fplIsAtomicCompareAndSwapSize()
	- @ref fplIsAtomicCompareAndSwapPtr()

	Usage:
	@code{.c}
	volatile uint32_t storageValue = 0;
	uint32_t oldValue = fplAtomicCompareAndSwapU32(&storageValue, 0, 1337);
	// The first thread executing this will see 0 as the oldValue, all others will see 1337

	// or
	volatile uint32_t storageValue = 0;
	if (fplIsAtomicCompareAndSwapU32(&storageValue, 0, 1337)) {
		// The first thread executing this to 1337 will get here
	} else {
		// All other threads gets here
	}
	@endcode

	@section section_category_threading_atomics_barriers Memory Barriers
	With memory barriers you can prevent the compiler from reordering memory reads/writes.<br>
	In FPL additional CPU fences may be added to ensure that the previous memory operations are completed before the future ones.<br>
	
	@subsection subsection_category_threading_atomics_barriers_without Without fences

	@code{.c}
	int theValue;
	int valueIsPublished = 0;
	void updateValue(int newValue) {
		// The compiler may move the write above the the value set
		theValue = newValue;
		valueIsPublished = 1;
	}

	int getValue() {
		// The compiler may move the read of value before the publish check
		if (valueIsPublished) {
			return theValue;
		}
		return -1;
	}
	@endcode

	@warning This example may break even on a single-threaded environment!

	@subsection subsection_category_threading_atomics_barriers_full With a read/write barrier

	@code{.c}
	int theValue;
	int valueIsPublished = 0;
	void updateValue(int newValue) {
		theValue = newValue;
		// The value is written before the publish is set
		fplAtomicReadWriteFence();
		valueIsPublished = 1;
	}

	int getValue() {
		// The publish is read before the value is being returned
		if (valueIsPublished) {
			fplAtomicReadWriteFence();
			return theValue;
		}
		return -1;
	}
	@endcode

	@subsection subsection_category_threading_atomics_barriers_read_or_write Read or Write
	In some special cases you don't have to issue a full memory barrier like @ref fplAtomicReadWriteFence(), so you can just use a read or write barrier only:<br>
	- You can use @ref fplAtomicReadFence() to just ensure memory writes are completed before future ones only (Plus preventing from compiler reording memory writes).<br>
	- You can use @ref fplAtomicWriteFence() to just ensure memory reads are completed before future ones only (Plus preventing from compiler reording memory reads).<br>

	@subsection subsection_category_threading_atomics_barriers_atomics Atomics vs Barriers?

	Atomic functions may include memory barriers to ensure that CPU memory read/write instructions are executed in order and to prevent the compiler from reordering memory read/writes.<br>
	This means you don't have to use any kind of memory barriers around atomic functions ;-)
	
*/

/*!
	@page page_category_threading_sync Synchronisation Methods
	@tableofcontents

	@todo(final): Explain why we need this

	@todo(final): Add examples of solving race conditions (Mutexes, Signals, Condition-Variables, Semaphores, Atomics)

	@todo(final): Add a comparison table to show the difference between the different types.
*/

/*!
	@page page_faq FAQ
	@tableofcontents

	@section section_faq FAQ

	@subsection subsection_faq_license What are the license requirements for FPL?
	Final Platform Layer is released under the @subpage page_license "MIT License".<br>
	This license allows you to use FPL freely in any software.<br>

	@subsection subsection_faq_costs I did pay for FPL, did i get ripped-of?
	Yes, you are! FPL is full open source and costs nothing.

	@subsection subsection_faq_inwhatlanguage In what language is FPL written?
	Final Platform Layer is written in C99 for simplicity and best portability, but is C++ compatible as well.<br>
	It uses standard types such as uint32_t or intptr_t from <stdint.h> <stddef.h> and <stdbool.h> to ensure correctness on all platforms.<br>
	For certain features such as printf(), getchar() the C Runtime are used but you can disable it if needed.<br>

	@subsection subsection_faq_whyshouldiuse What makes it different from other platform abstraction libraries, such as SDL/SFML etc. ?
	- FPL is designed to require bare minimum linking to the OS (kernel32.lib / libld.so) only.
	- It does not require any dependencies or build-systems to get it running.
	- It has a lightweight feature set.
	- No data hiding -> everything is accessible.
	- It uses a fixed and small memory footprint and handles memory very gracefully.
	- It can be controlled by a configuration structure in very detail at startup.
	- You decide how to integrate it; not the library.

	@subsection subsection_faq_whyisfplsobig Why is FPL so big?
	Final Platform Layer contains headers and implementations for all supported platforms with all the function prototypes for linking operating system functions dynamically.<br>
	In addition there is a full detailed changelog included as well.<br>

	@subsection subsection_faq_howdoesitwork How does it work?
	FPL relies heavy on preprocessor defines used for detecting the current architecture / compiler / operating system.<br>
	This makes it possible to enable/disable certain code-paths for certain platform/compiler combinations.<br>
	Only built-in OS operating system functions are used in almost every situation and the usage of standard library functions is prevented by all means.<br>
	<br>
	Platforms are either full implemented platforms or a subset of sub-platforms.<br>
	On top of that we have audio/video drivers for certain platforms/sub-platforms.<br>
	Lastly there is a abstraction layer api which merges the platforms/subplatforms/drivers into structures/unions.

	@subsection subsection_faq_limitations Does FPL have some limitations?
	Yes it does have some limitations, because it cannot do everything for you:
	- There is no audio DSP going on, so you have to convert the samples into the proper format (Sample rate, Channels, Format type) FPL expects.
	- There is no rendering functions included, except for presenting the current frame. So you have to load and call the correct api functions yourself.
	- FPL has a lightweight feature set, so it may not have all the features you may need.

	@subsection subsection_faq_strings How does FPL handle strings?
	On every platform all strings/paths are expected to be UTF-8 always!<br>
	If you need to convert Unicode/UTF-16 based strings there are conversion functions built-in.

	@subsection subsection_faq_thirdparty_libs Can FPL handle third party libraries?
	Yes actually it works very well with other libraries - in fact there are several demo projects in the repository which shows that.<br>
	<br>
	Here is a short list of tested third-party libraries with FPL:

	- C-Standard Library
	- C++ Standard Template Library
	- STB Libraries
	- Glew/Glad
	- PhysX
	- Box2D
	- GLM
	- ImGUI
	- FFMPEG

	But it wont work with other platform abstraction libraries such as SDL, SFML, GLUT, GLFW etc.<br>
	All these other platform abstraction libraries have their own way of providing the main entry point and are not compability with each other.
*/

/*!
	@page page_contribute How to contribute to FPL
	@tableofcontents

	@section section_contribute_time Give time

	If you have time, i welcome your help in various areas:<br>
	- **Programmers**: Write demos, help me in fixing bugs, introduce new platforms, etc.
	- **Writers**: Improve of the documentation
	- **Testing**: Test FPL on different platforms/compilers
	- **Report bugs**: Report bugs (https://github.com/f1nalspace/final_game_tech/issues)
	- **Send in feedback**: Write feedback, post ideas (https://fpl.handmade.network/forums)

	@section section_contribute_donate Donate money

	FPL is a one-man project, so i really appreciate any kind of financial support.

	@subsection subsection_contribute_donate_needs What are the financial needs of FPL?
	- Maintaining the official webpage (https://libfpl.org)
	- Extending the Jetbrains CLion license
	- Buying hardware for developing and testing purposes (Computers, Soundcards, etc.)

	@subsection subsection_contribute_donate_donate Donate to FPL

	You can donate money to the projects own paypal account. There is no minimal amount for your donation.<br>
	Below you can find buttons which takes you to the secure paypal web site.

	https://www.paypal.com
*/

/*!
	@page page_examples Examples
	@tableofcontents

	@section section_console_examples Console examples

	- @subpage page_example_helloworld_console
	- @subpage page_example_simple_audio

	@section section_windowed_examples Window examples

	- @subpage page_example_opengl1x
	- @subpage page_example_opengl33
*/

/*!
	@page page_nocrt How to disable the use of the CRT in FPL
	@tableofcontents

	@section section_nocrt_consequences Consequences of disabling the CRT

	If you disable the CRT, you lose a lot of functionality which we today take for granted:<br>

	- No functions from the entire C standard library stack, such as "stdio.h" / "stdlib", / "math.h" / "string.h", etc.
	- No or limited integer mul/div operations on some platforms
	- No console input/output
	- No C++ exceptions
	- Limited security checks
	- No automatic entry point mapping to main() or WinMain()
	- Limited floating point operations on some platforms
	- Limited stack size

	Some limitations can be corrected by setting up the compiler properly, such as stack size, security checks, etc.<br>
	<br>
	So if you are fine with that, the next section describes how to do disable the CRT usage in FPL.

	@section section_nocrt_requirements Requirements for disabling the CRT in FPL

	- You have read the @ref section_nocrt_consequences
	- You know what you are doing
	- You already disabled the CRT by compiler settings
	- You fixed the security checks and stack size by compiler settings

	@section bsection_nocrt_disableit Disable the CRT in FPL

	To disable the use of the C-Runtime Library, you need to set certain preprocessor definitions:

	- Define **FPL_NO_CRT** in all translation units where FPL implementation is included
	- In your main translation unit, you need to define the application type **FPL_APPTYPE_CONSOLE** or **FPL_APPTYPE_WINDOW** explicitly

	@code{.c}
	#define FPL_NO_CRT // Disable CRT support in FPL
	#define FPL_APPTYPE_CONSOLE // or FPL_APPTYPE_WINDOW
	#define FPL_IMPLEMENTATION // FPL_NO_CRT must be set set in the implementation only
	#include <final_platform_layer.h>
	@endcode

	@section section_nocrt_provfunccrt Providing intrinsics (Mini-CRT)

	Some compilers such as MSVC require certain stuff to compile properly.<br>
	You are responsible to provide that stuff if you get compile errors.<br>
	<br>
	A few errors you may get:

	Runtime check:
	- unresolved external symbol __RTC_Shutdown
	- unresolved external symbol __RTC_InitBase
	- unresolved external symbol __RTC_CheckEsp
	- unresolved external symbol __RTC_CheckStackVars

	Float:
	- unresolved external symbol __fltused -> Global used in MSVC
	- unresolved external symbol __ltod3 -> Double division intrinsic

	Integer:
	- unresolved external symbol __allmul -> Long-Long integer multiplication intrinsic

	Other:
	- unresolved external symbol __memset -> memset intrinsic (May use fplMemorySet)
	- unresolved external symbol __memcpy -> memcpy intrinsic (May use fplMemoryCopy)

	To solve this compile errors it is recommended to use a mini-crt library or write all the functions yourself.<br>

	@section section_nocrt_notes Notes

	Right know FPL have No-CRT support for Win32 only! If you need this for other platforms let me know.
*/

/*!
	@page page_compiler_options Compiler Options
	@tableofcontents

	@section section_compiler_options_preprocessor_opts Preprocessor options

	<table>
		<tr><th>Category</th><th>Macro definition</th><th>Description</th><th>Default</th></tr>

		<tr>
			<td>System</td>
			<td>FPL_IMPLEMENTATION</td>
			<td>
				Define this to include the actual implementation code.<br>
				Set this only once per translation unit, otherwise you will get linking errors.
			</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_NO_ENTRYPOINT</td>
			<td>
				Define this to disable the entry point inclusion.<br>
				This is useful when you use FPL in multiple translation units, but want your main entry point to be included only once.
			</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_ENTRYPOINT</td>
			<td>
				Force the inclusion of the main entry point.<br>
				If you use FPL as a static library, you need to set this in your main translation unit only.
			</td>
			<td>Automatically set when FPL_IMPLEMENTATION is defined, but only when FPL_NO_ENTRYPOINT is _not_ defined</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_API_AS_PRIVATE</td>
			<td>
				Define this to make all functions be private ( <b>static</b> ).<br>
				This means that all function calls can be called from one translation unit only.
			</td>
			<td>By default all FPL functions are defined as ( <b>extern</b> )</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_DEBUG</td>
			<td>
				Define this to enable the "Debug" configuration.<br>
				When set assertions and some debug related features are enabled.
			</td>
			<td>By default this is auto-detected by compiler settings.</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_RELEASE</td>
			<td>
				Define this to enable the "Release" configuration.<br>
				When set all DEBUG features are compiled out entirely.
			</td>
			<td>By default this is auto-detected by compiler settings.</td>
		</tr>
		<tr>
			<td>System</td>
			<td>FPL_NO_RUNTIME_LINKING</td>
			<td>
				Define this to disable runtime linking of libraries.<br>
			</td>
			<td>Not set by default</td>
		</tr>

		<tr>
			<td>Assertions</td>
			<td>FPL_NO_ASSERTIONS</td>
			<td>Define this to disable all internal assertions.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Assertions</td>
			<td>FPL_FORCE_ASSERTIONS</td>
			<td>Define this to enable internal assertions always, even in release builds.</td>
			<td>
			Not set by default.<br>
			@note When enabled all assertions will use a simple null-pointer assertion macro always!
			</td>
		</tr>
		<tr>
			<td>Assertions</td>
			<td>FPL_NO_C_ASSERT</td>
			<td>Define this to disable C runtime assert.</td>
			<td>
			Not set by default.<br>
			@note Has no effect when FPL_FORCE_ASSERTIONS is set!
			</td>
		</tr>

		<tr>
			<td>Window</td>
			<td>FPL_NO_WINDOW</td>
			<td>Define this to disable Window Support entirely.</td>
			<td>Not set by default</td>
		</tr>

		<tr>
			<td>Video</td>
			<td>FPL_NO_VIDEO</td>
			<td>Define this to disable Video Support entirely.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Video</td>
			<td>FPL_NO_VIDEO_OPENGL</td>
			<td>Define this to disable the OpenGL Video Driver.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Video</td>
			<td>FPL_NO_VIDEO_SOFTWARE</td>
			<td>Define this to disable the Software Video Driver.</td>
			<td>Not set by default</td>
		</tr>

		<tr>
			<td>Audio</td>
			<td>FPL_NO_AUDIO</td>
			<td>Define this to disable Audio Support entirely.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Audio</td>
			<td>FPL_NO_AUDIO_DIRECTSOUND</td>
			<td>Define this to disable DirectSound support entirely.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Audio</td>
			<td>FPL_NO_AUDIO_ALSA</td>
			<td>Define this to disable ALSA support entirely.</td>
			<td>Not set by default</td>
		</tr>

		<tr>
			<td>Logging</td>
			<td>FPL_LOGGING</td>
			<td>Define this to enable logging.</td>
			<td>Not set by default</td>
		</tr>
		<tr>
			<td>Logging</td>
			<td>FPL_LOG_MULTIPLE_WRITERS</td>
			<td>Define this to support multiple log writers, so you can have a writer for each log level.</td>
			<td>Not set by default</td>
		</tr>

		<tr>
			<td>C-Runtime</td>
			<td>FPL_NO_CRT</td>
			<td>Define this to disable the usage of functions from the CRT.</td>
			<td>This is not set by default.</td>
		</tr>

		<tr>
			<td>Application</td>
			<td>FPL_NO_APPTYPE</td>
			<td>Define this to disable the application type detection.</td>
			<td>By default this are not set and the application type is detected automatically.</td>
		</tr>
		<tr>
			<td>Application</td>
			<td>FPL_APPTYPE_CONSOLE</td>
			<td>Define this to force your application to be a console application.<br>When this is set the window support will be compiled out!</td>
			<td>By default this are set when FPL_NO_WINDOW is defined.</td>
		</tr>
		<tr>
			<td>Application</td>
			<td>FPL_APPTYPE_WINDOW</td>
			<td>Define this to force your application to be a windowed application.</td>
			<td>By default this is	 set when FPL_NO_WINDOW is _not_ defined.</td>
		</tr>

		<tr>
			<td>User functions</td>
			<td>FPL_USERFUNC_vsnprintf</td>
			<td>Define this to provide a replacement for vsnprintf() when FPL_NO_CRT is set.</td>
			<td>By default this is not set.</td>
		</tr>

	</table>	

	@section section_compiler_options_detection Platform/Compiler detection

	Like every other C/C++ program, FPL uses compiler defines to detect the proper platform/architecture and used compiler.<br>
	If you need this information for whatever reason you can simply compare the defines:

	- **FPL_PLATFORM_WIN32** or **FPL_PLATFORM_LINUX** or **FPL_PLATFORM_UNIX** ...
	- **FPL_ARCH_X64** or **FPL_ARCH_X86** or **FPL_ARCH_ARM64* ...

	All these defines have no values set, there are just "defined" - use always defined() for checking them.

	@code{.c}
	#if defined(FPL_PLATFORM_WIN32)
		// ... Any win32 code you may need
	#endif // FPL_PLATFORM_WIN32

	#if defined(FPL_ARCH_X64)
		// ... Any x64 code you may need
	#endif // FPL_ARCH_X64

	#if defined(FPL_COMPILER_MSVC)
		// ... MSVC compiler specific code you may need
	#endif // FPL_COMPILER_MSVC
	@endcode

	@section section_compiler_options_subplatform Sub-Platforms

	To prevent code duplication for platform combinations, FPL uses sub-platforms - which are no real platforms, but rather principles or standards the actual operating system is built-on.<br>
	For example "Linux" is detected as **FPL_PLATFORM_LINUX** but uses POSIX as a sub-platform **FPL_SUBPLATFORM_POSIX**.<br>
	Another example is "FreeBSD" which is a unix-based operation system which uses POSIX standards as well, so it uses the same posix sub platform.<br>
*/

/*!
	@page page_example_helloworld_console Hello World Console Application!
	@tableofcontents

	@section section_maincpp1 main.cpp

	@code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"

	int main(int argc, char **argv) {
		int result;
		if (fplPlatformInit(fplInitFlags_Console)) {
			fplConsoleOut("Hello World!");
			fplPlatformRelease();
			result = 0;
		} else {
			result = -1;
		}
		return(result);
	}
	@endcode

*/

/*!
	@page page_example_opengl1x Simple OpenGL 1.x
	@tableofcontents

	@section section_maincpp2 main.cpp

	@code{.c}
	#define FPL_IMPLEMENTATION
	#include "final_platform_layer.h"

	// You have to include GL.h yourself or use any other opengl loader you want.
	// FPL just creates a opengl rendering context for you, but nothing more.
	#include <GL\GL.h>

	int main(int argc, char **argv) {
		int result = 0;
		if (fplPlatformInit(fplInitFlags_Video, fpl_null)) {
			glClearColor(0.39f, 0.58f, 0.93f, 1.0f);
			while (fplWindowUpdate()) {
				fplEvent ev;
				while (fplPollEvent(&ev)) {}

				fplWindowSize windowArea = fplGetWindowSize();
				glViewport(0, 0, windowArea.width, windowArea.height);
				glClear(GL_COLOR_BUFFER_BIT);
				glBegin(GL_TRIANGLES);
				glVertex2f(0.0f, 0.5f);
				glVertex2f(-0.5f, -0.5f);
				glVertex2f(0.5f, -0.5f);
				glEnd();
				fplVideoFlip();
			}
			fplPlatformRelease();
			result = 0;
		} else {
			result = -1;
		}
		return(result);
	}
	@endcode

*/

/*!
	@page page_example_opengl33 Modern OpenGL 3.3+
	@tableofcontents

	@section section_maincpp3 main.cpp

	@code{.c}
		#define FPL_IMPLEMENTATION
		#define FPL_NO_VIDEO_SOFTWARE
		#define FPL_NO_AUDIO
		#include <final_platform_layer.h>

		// You have to include GL.h yourself or use any other opengl loader you want.
		// FPL just creates a opengl rendering context for you, but nothing more.
		#include <GL/gl.h>

		#ifndef APIENTRY
		#define APIENTRY
		#endif
		#define APIENTRYP APIENTRY *

		#include <stddef.h>
		typedef ptrdiff_t GLsizeiptr;
		typedef ptrdiff_t GLintptr;
		typedef char GLchar;

		#ifndef GL_CONTEXT_PROFILE_MASK

		#define GL_CONTEXT_PROFILE_MASK           0x9126
		#define GL_CONTEXT_FLAGS                  0x821E

		#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT	0x0001
		#define GL_CONTEXT_FLAG_DEBUG_BIT				0x00000002
		#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT		0x00000004
		#define GL_CONTEXT_FLAG_NO_ERROR_BIT			0x00000008
		#define GL_CONTEXT_CORE_PROFILE_BIT				0x00000001
		#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT	0x00000002

		#endif // GL_CONTEXT_PROFILE_MASK

		#define GL_COMPILE_STATUS                 0x8B81
		#define GL_INFO_LOG_LENGTH                0x8B84
		#define GL_FRAGMENT_SHADER                0x8B30
		#define GL_VERTEX_SHADER                  0x8B31
		#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
		#define GL_LINK_STATUS                    0x8B82
		#define GL_STATIC_DRAW                    0x88E4

		typedef GLuint(APIENTRYP PFNGLCREATESHADERPROC) (GLenum type);
		typedef void (APIENTRYP PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
		typedef void (APIENTRYP PFNGLCOMPILESHADERPROC) (GLuint shader);
		typedef void (APIENTRYP PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
		typedef void (APIENTRYP PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
		typedef GLuint(APIENTRYP PFNGLCREATEPROGRAMPROC) (void);
		typedef void (APIENTRYP PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
		typedef void (APIENTRYP PFNGLLINKPROGRAMPROC) (GLuint program);
		typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPROC) (GLuint program);
		typedef void (APIENTRYP PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
		typedef void (APIENTRYP PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
		typedef void (APIENTRYP PFNGLDELETESHADERPROC) (GLuint shader);
		typedef void (APIENTRYP PFNGLUSEPROGRAMPROC) (GLuint program);

		static PFNGLCREATESHADERPROC glCreateShader = NULL;
		static PFNGLSHADERSOURCEPROC glShaderSource = NULL;
		static PFNGLCOMPILESHADERPROC glCompileShader = NULL;
		static PFNGLGETSHADERIVPROC glGetShaderiv = NULL;
		static PFNGLATTACHSHADERPROC glAttachShader = NULL;
		static PFNGLCREATEPROGRAMPROC glCreateProgram = NULL;
		static PFNGLGETSHADERINFOLOGPROC glGetShaderInfoLog = NULL;
		static PFNGLLINKPROGRAMPROC glLinkProgram = NULL;
		static PFNGLVALIDATEPROGRAMPROC glValidateProgram = NULL;
		static PFNGLGETPROGRAMIVPROC glGetProgramiv = NULL;
		static PFNGLGETPROGRAMINFOLOGPROC glGetProgramInfoLog = NULL;
		static PFNGLDELETESHADERPROC glDeleteShader = NULL;
		static PFNGLUSEPROGRAMPROC glUseProgram = NULL;

		#define GL_ARRAY_BUFFER                   0x8892

		typedef void (APIENTRYP PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint *arrays);
		typedef void (APIENTRYP PFNGLBINDVERTEXARRAYPROC) (GLuint array);
		typedef void (APIENTRYP PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
		typedef void (APIENTRYP PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
		typedef void (APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void *data, GLenum usage);
		typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
		typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
		typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
		typedef void (APIENTRYP PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint *arrays);

		static PFNGLGENVERTEXARRAYSPROC glGenVertexArrays = NULL;
		static PFNGLBINDVERTEXARRAYPROC glBindVertexArray = NULL;
		static PFNGLGENBUFFERSPROC glGenBuffers = NULL;
		static PFNGLBINDBUFFERPROC glBindBuffer = NULL;
		static PFNGLBUFFERDATAPROC glBufferData = NULL;
		static PFNGLENABLEVERTEXATTRIBARRAYPROC glEnableVertexAttribArray = NULL;
		static PFNGLDISABLEVERTEXATTRIBARRAYPROC glDisableVertexAttribArray = NULL;
		static PFNGLVERTEXATTRIBPOINTERPROC glVertexAttribPointer = NULL;
		static PFNGLDELETEVERTEXARRAYSPROC glDeleteVertexArrays = NULL;

		#if defined(FPL_PLATFORM_WINDOWS)
		static void *GLProcAddress(const char *name) {
			fpl__VideoState *videoState = (fpl__VideoState *)fpl__global__AppState->video.mem;
			fplAssert(videoState != NULL);
			fplAssert(videoState->win32.opengl.api.wglGetProcAddress != NULL);
			void *result = videoState->win32.opengl.api.wglGetProcAddress(name);
			return(result);
		}
		#else
		static void *GLProcAddress(const char *name) {
			fpl__VideoState *videoState = (fpl__VideoState *)fpl__global__AppState->video.mem;
			fplAssert(videoState != NULL);
			fplAssert(videoState->x11.opengl.api.glXGetProcAddress != NULL);
			void *result = videoState->x11.opengl.api.glXGetProcAddress((const GLubyte *)name);
			return(result);
		}
		#endif

		static void LoadGLExtensions() {
			glCreateShader = (PFNGLCREATESHADERPROC)GLProcAddress("glCreateShader");
			glShaderSource = (PFNGLSHADERSOURCEPROC)GLProcAddress("glShaderSource");
			glCompileShader = (PFNGLCOMPILESHADERPROC)GLProcAddress("glCompileShader");
			glGetShaderiv = (PFNGLGETSHADERIVPROC)GLProcAddress("glGetShaderiv");
			glAttachShader = (PFNGLATTACHSHADERPROC)GLProcAddress("glAttachShader");
			glCreateProgram = (PFNGLCREATEPROGRAMPROC)GLProcAddress("glCreateProgram");
			glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)GLProcAddress("glGetShaderInfoLog");
			glLinkProgram = (PFNGLLINKPROGRAMPROC)GLProcAddress("glLinkProgram");
			glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)GLProcAddress("glValidateProgram");
			glGetProgramiv = (PFNGLGETPROGRAMIVPROC)GLProcAddress("glGetProgramiv");
			glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)GLProcAddress("glGetProgramInfoLog");
			glDeleteShader = (PFNGLDELETESHADERPROC)GLProcAddress("glDeleteShader");
			glUseProgram = (PFNGLUSEPROGRAMPROC)GLProcAddress("glUseProgram");

			glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)GLProcAddress("glGenVertexArrays");
			glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)GLProcAddress("glBindVertexArray");
			glGenBuffers = (PFNGLGENBUFFERSPROC)GLProcAddress("glGenBuffers");
			glBindBuffer = (PFNGLBINDBUFFERPROC)GLProcAddress("glBindBuffer");
			glBufferData = (PFNGLBUFFERDATAPROC)GLProcAddress("glBufferData");
			glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)GLProcAddress("glEnableVertexAttribArray");
			glDisableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)GLProcAddress("glDisableVertexAttribArray");
			glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)GLProcAddress("glVertexAttribPointer");
			glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)GLProcAddress("glDeleteVertexArrays");
		}

		#define MODERN_OPENGL 1

		static GLuint CreateShaderType(GLenum type, const char *source) {
			GLuint shaderId = glCreateShader(type);

			glShaderSource(shaderId, 1, &source, NULL);
			glCompileShader(shaderId);

			char info[1024 * 10] = fplZeroInit;

			GLint compileResult;
			glGetShaderiv(shaderId, GL_COMPILE_STATUS, &compileResult);
			if(!compileResult) {
				GLint infoLen;
				glGetShaderiv(shaderId, GL_INFO_LOG_LENGTH, &infoLen);
				fplAssert(infoLen <= fplArrayCount(info));
				glGetShaderInfoLog(shaderId, infoLen, &infoLen, info);
				fplConsoleFormatError("Failed compiling %s shader!\n", (type == GL_VERTEX_SHADER ? "vertex" : "fragment"));
				fplConsoleFormatError("%s\n", info);
			}

			return(shaderId);
		}

		static GLuint CreateShaderProgram(const char *name, const char *vertexSource, const char *fragmentSource) {
			GLuint programId = glCreateProgram();

			GLuint vertexShader = CreateShaderType(GL_VERTEX_SHADER, vertexSource);
			GLuint fragmentShader = CreateShaderType(GL_FRAGMENT_SHADER, fragmentSource);

			glAttachShader(programId, vertexShader);
			glAttachShader(programId, fragmentShader);
			glLinkProgram(programId);
			glValidateProgram(programId);

			char info[1024 * 10] = fplZeroInit;

			GLint linkResult;
			glGetProgramiv(programId, GL_LINK_STATUS, &linkResult);
			if(!linkResult) {
				GLint infoLen;
				glGetProgramiv(programId, GL_INFO_LOG_LENGTH, &infoLen);
				fplAssert(infoLen <= fplArrayCount(info));
				glGetProgramInfoLog(programId, infoLen, &infoLen, info);
				fplConsoleFormatError("Failed linking '%s' shader!\n", name);
				fplConsoleFormatError("%s\n", info);
			}

			glDeleteShader(fragmentShader);
			glDeleteShader(vertexShader);

			return(programId);
		}

		static bool RunModern() {
			LoadGLExtensions();

			GLuint vertexArrayID;
			glGenVertexArrays(1, &vertexArrayID);
			glBindVertexArray(vertexArrayID);

			const char *glslVersion = (const char *)glGetString(GL_SHADING_LANGUAGE_VERSION);
			fplConsoleFormatOut("OpenGL GLSL Version %s:\n", glslVersion);

			int profileMask;
			int contextFlags;
			glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &profileMask);
			glGetIntegerv(GL_CONTEXT_FLAGS, &contextFlags);
			fplConsoleFormatOut("OpenGL supported profiles:\n");
			fplConsoleFormatOut("\tCore: %s\n", ((profileMask & GL_CONTEXT_CORE_PROFILE_BIT) ? "yes" : "no"));
			fplConsoleFormatOut("\tForward: %s\n", ((contextFlags & GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT) ? "yes" : "no"));

			fplConsoleOut("Running modern opengl\n");

			const char vertexSource[] = {
				"#version 330 core\n"
				"\n"
				"layout(location = 0) in vec4 inPosition;\n"
				"\n"
				"void main() {\n"
				"\tgl_Position = inPosition;\n"
				"}\n"
			};

			const char fragmentSource[] = {
				"#version 330 core\n"
				"\n"
				"layout(location = 0) out vec4 outColor;\n"
				"\n"
				"void main() {\n"
				"\toutColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
				"}\n"
			};

			GLuint shaderProgram = CreateShaderProgram("Test", vertexSource, fragmentSource);

			float vertices[] = {
				0.0f, 0.5f,
				-0.5f, -0.5f,
				0.5f, -0.5f
			};
			GLuint buffer;
			glGenBuffers(1, &buffer);
			glBindBuffer(GL_ARRAY_BUFFER, buffer);
			glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
			glBindBuffer(GL_ARRAY_BUFFER, 0);

			glUseProgram(shaderProgram);

			glBindBuffer(GL_ARRAY_BUFFER, buffer);
			glEnableVertexAttribArray(0);
			glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, NULL);

			glClearColor(0.39f, 0.58f, 0.93f, 1.0f);
			while(fplWindowUpdate()) {
				fplEvent ev;
				while(fplPollEvent(&ev)) {}

				fplWindowSize windowArea;
				fplGetWindowSize(&windowArea);
				glViewport(0, 0, windowArea.width, windowArea.height);

				glClear(GL_COLOR_BUFFER_BIT);

				glDrawArrays(GL_TRIANGLES, 0, 3);

				fplVideoFlip();
			}

			glDisableVertexAttribArray(0);
			glBindBuffer(GL_ARRAY_BUFFER, 0);

			glBindVertexArray(0);
			glDeleteVertexArrays(1, &vertexArrayID);

			return true;
		}

		int main(int argc, char **args) {
			int result = 0;
			fplSettings settings = fplMakeDefaultSettings();
			settings.video.driver = fplVideoDriverType_OpenGL;
			fplCopyString("FPL Modern OpenGL", settings.window.title, fplArrayCount(settings.window.title));
			settings.video.graphics.opengl.compabilityFlags = fplOpenGLCompabilityFlags_Core;
			settings.video.graphics.opengl.majorVersion = 3;
			settings.video.graphics.opengl.minorVersion = 3;
			settings.video.graphics.opengl.multiSamplingCount = 4;
			if(fplPlatformInit(fplInitFlags_Video, &settings)) {
				const char *version = (const char *)glGetString(GL_VERSION);
				const char *vendor = (const char *)glGetString(GL_VENDOR);
				const char *renderer = (const char *)glGetString(GL_RENDERER);
				fplConsoleFormatOut("OpenGL version: %s\n", version);
				fplConsoleFormatOut("OpenGL vendor: %s\n", vendor);
				fplConsoleFormatOut("OpenGL renderer: %s\n", renderer);
				RunModern();
				fplPlatformRelease();
				result = 0;
			} else {
				result = -1;
			}
			return(result);
		}
	@endcode

*/

/*!
	@page page_example_simple_audio Simple audio playback
	@tableofcontents

	@section section_maincpp4 main.cpp

	@code{.c}
	#define FPL_IMPLEMENTATION
	#define FPL_NO_WINDOW
	#include <final_platform_layer.h>
	#include <math.h> // sinf

	struct AudioTest {
		uint32_t toneHz;
		uint32_t toneVolume;
		uint32_t runningSampleIndex;
		uint32_t wavePeriod;
		bool useSquareWave;
	};

	static const float PI32 = 3.14159265359f;

	static uint32_t FillAudioBuffer(const fplAudioDeviceFormat *nativeFormat, const uint32_t frameCount, void *outputSamples, void *userData) {
		AudioTest *audioTest = (AudioTest *)userData;
		fplAssert(audioTest != nullptr);
		fplAssert(nativeFormat->type == fplAudioFormatType_S16);
		uint32_t result = 0;
		int16_t *outSamples = (int16_t *)outputSamples;
		uint32_t halfWavePeriod = audioTest->wavePeriod / 2;
		for (uint32_t frameIndex = 0; frameIndex < frameCount; ++frameIndex) {
			int16_t sampleValue;
			if (audioTest->useSquareWave) {
				sampleValue = ((audioTest->runningSampleIndex++ / halfWavePeriod) % 2) ? (int16_t)audioTest->toneVolume : -(int16_t)audioTest->toneVolume;
			} else {
				float t = 2.0f * PI32 * (float)audioTest->runningSampleIndex++ / (float)audioTest->wavePeriod;
				sampleValue = (int16_t)(sinf(t) * audioTest->toneVolume);
			}
			for (uint32_t channelIndex = 0; channelIndex < nativeFormat->channels; ++channelIndex) {
				*outSamples++ = sampleValue;
				++result;
			}
		}
		return result;
	}

	int main(int argc, char **argv) {
		int result = -1;

		// Initialize to default settings which is 48 KHz and 2 Channels
		fplSettings settings;
		fplSetDefaultSettings(&settings);

		// Optionally overwrite audio settings if needed

		// Setup some state for the sine/square wave generation
		AudioTest audioTest = {};
		audioTest.toneHz = 256;
		audioTest.toneVolume = 1000;
		audioTest.wavePeriod = settings.audio.deviceFormat.sampleRate / audioTest.toneHz;
		audioTest.useSquareWave = false;

		// Provide client read callback and optionally user data
		settings.audio.clientReadCallback = FillAudioBuffer;
		settings.audio.userData = &audioTest;
		settings.audio.deviceFormat.type = fplAudioFormatType_S16;
		settings.audio.deviceFormat.channels = 2;
		settings.audio.deviceFormat.sampleRate = 48000;

		// Disable auto start/stop of audio playback
		settings.audio.startAuto = false;
		settings.audio.stopAuto = false;

		// Find audio device
		if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
			fplAudioDeviceID audioDevices[16] = {};
			uint32_t deviceCount = fplGetAudioDevices(audioDevices, fplArrayCount(audioDevices));
			if (deviceCount > 0) {
				settings.audio.deviceID = audioDevices[0];
				fplConsoleFormatOut("Using audio device: %s\n", settings.audio.deviceID.name);
			}
			fplPlatformRelease();
		}

		// Initialize the platform with audio enabled and the settings
		if (fplPlatformInit(fplInitFlags_Audio, &settings)) {
			// You can overwrite the client read callback and user data if you want to
			fplSetAudioClientReadCallback(FillAudioBuffer, &audioTest);
			// Start audio playback (This will start calling clientReadCallback regulary)
			if (fplPlayAudio() == fplAudioResult_Success) {
				// Print out the native audio format
				fplAudioDeviceFormat nativeFormat = fplGetAudioHardwareFormat();
				fplConsoleFormatOut("Audio with %lu KHz and %lu channels is playing, press any key to stop playback...\n", nativeFormat.sampleRate, nativeFormat.channels);
				// Wait for any key presses
				fplConsoleWaitForCharInput();
				// Stop audio playback
				fplStopAudio();
			}
			// Release the platform
			fplPlatformRelease();
			result = 0;
		}
		return(result);
	}
	@endcode

*/

/*!
	@page page_license License
	@tableofcontents

	@section section_mit_license MIT License

	Copyright (c) 2017-2019 Torsten Spaete<br>
	<br>
	Permission is hereby granted, free of charge, to any person obtaining a copy of<br>
	this software and associated documentation files (the "Software"), to deal in<br>
	the Software without restriction, including without limitation the rights to<br>
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies<br>
	of the Software, and to permit persons to whom the Software is furnished to do<br>
	so, subject to the following conditions:<br>
	<br>
	The above copyright notice and this permission notice shall be included in all<br>
	copies or substantial portions of the Software.<br>
	<br>
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>
	SOFTWARE.<br>
*/